<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>server/autopilot.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Dark theme matching app style - carefully scoped to not break layout */
        html, body {
            background-color: #1a1a1a !important;
            color: #e0e0e0 !important;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
            overflow-x: hidden !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        /* Custom scrollbar styling for all browsers */
        * {
            scrollbar-width: thin !important;
            scrollbar-color: #404040 #1a1a1a !important;
        }

        /* Webkit browsers (Chrome, Safari, Edge) */
        *::-webkit-scrollbar {
            width: 6px !important;
            height: 6px !important;
        }

        *::-webkit-scrollbar-track {
            background: #1a1a1a !important;
        }

        *::-webkit-scrollbar-thumb {
            background-color: #404040 !important;
            border-radius: 3px !important;
        }

        *::-webkit-scrollbar-thumb:hover {
            background-color: #505050 !important;
        }

        /* Navigation sidebar - remove padding and white borders */
        nav {
            background-color: #242424 !important;
            border-right: 1px solid #404040 !important;
            padding: 0 !important;
            margin: 0 !important;
            overflow-x: hidden !important;
        }
        nav h2, nav h3 {
            color: #e0e0e0 !important;
            border-bottom: 1px solid #404040 !important;
            padding: 10px 15px !important;
            margin: 0 !important;
            background-color: #242424 !important;
            font-size: 14px !important;
            font-weight: 600 !important;
        }
        nav h3 {
            font-size: 13px !important;
        }
        nav ul {
            padding: 0 !important;
            margin: 0 !important;
            background-color: #242424 !important;
        }
        nav ul li {
            list-style: none !important;
            margin: 0 !important;
            padding: 0 !important;
            background-color: #242424 !important;
        }
        nav ul li a {
            color: #c9d1d9 !important;
            display: block !important;
            padding: 8px 15px !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            background-color: #242424 !important;
            margin: 0 !important;
            border: none !important;
            font-size: 14px !important;
        }
        nav ul li a:hover {
            color: #60a5fa !important;
            background-color: rgba(96, 165, 250, 0.1) !important;
        }
        /* Module links (direct children of nav > ul > li) */
        nav > ul > li > a {
            color: #60a5fa !important;
            font-weight: 600 !important;
            padding: 10px 15px !important;
            font-size: 14px !important;
            border-left: 3px solid #60a5fa !important;
            padding-left: 12px !important;
        }
        nav > ul > li > a:hover {
            background-color: rgba(96, 165, 250, 0.15) !important;
        }
        /* Sub-items (methods/functions) indented */
        nav ul.methods {
            padding-left: 15px !important;
        }
        nav ul.methods li a {
            color: #9ca3af !important;
            font-size: 13px !important;
            padding: 6px 15px !important;
            font-weight: 400 !important;
        }
        nav ul.methods li a:hover {
            color: #c9d1d9 !important;
        }
        nav > h2:first-child {
            font-size: 16px !important;
            font-weight: 700 !important;
            padding: 12px 15px !important;
        }

        /* Main content area - dark background */
        #main {
            background-color: #1a1a1a !important;
            padding: 20px !important;
        }

        /* Article and sections - ensure dark background */
        article, section, .container-overview, .description {
            background-color: #1a1a1a !important;
        }

        /* Images - style demo images */
        img {
            max-width: 100% !important;
            height: auto !important;
            border: 1px solid #404040 !important;
            border-radius: 8px !important;
            margin: 20px 0 !important;
        }

        /* Links */
        a {
            color: #60a5fa !important;
            text-decoration: none !important;
        }
        a:hover {
            color: #93c5fd !important;
            text-decoration: underline !important;
        }

        /* Headings */
        h1, h2, h3, h4, h5, h6 {
            color: #e0e0e0 !important;
            border-bottom-color: #404040 !important;
            background-color: transparent !important;
        }
        h4.name {
            background-color: #2a2a2a !important;
            border: 1px solid #404040 !important;
        }

        /* Code blocks */
        pre {
            background-color: #0d1117 !important;
            border: 1px solid #404040 !important;
        }
        pre code {
            background-color: transparent !important;
        }
        code {
            background-color: #2a2a2a !important;
            color: #e0e0e0 !important;
            padding: 2px 6px !important;
            border-radius: 3px !important;
        }

        /* Tables */
        table {
            border-color: #404040 !important;
            background-color: #1a1a1a !important;
        }
        table thead tr {
            background-color: #242424 !important;
        }
        table tbody tr {
            background-color: #1a1a1a !important;
        }
        table tbody tr:nth-child(even) {
            background-color: #1f1f1f !important;
        }
        table td, table th {
            border-color: #404040 !important;
            color: #e0e0e0 !important;
            background-color: transparent !important;
        }
        .params .name, .props .name {
            color: #10b981 !important;
            font-family: 'Courier New', monospace !important;
        }

        /* Descriptions and details */
        .description, .details, dt, dd, p, ul, ol, dl {
            color: #e0e0e0 !important;
            background-color: transparent !important;
        }

        /* Types */
        .type-signature {
            color: #a78bfa !important;
        }

        /* Source links */
        .details .details-item-container {
            border-left-color: #404040 !important;
        }

        /* Breadcrumbs */
        .page-title {
            color: #e0e0e0 !important;
        }

        /* Search */
        #nav-search {
            background-color: #2a2a2a !important;
            border: 1px solid #404040 !important;
            color: #e0e0e0 !important;
        }

        /* Mobile nav trigger */
        .navicon-button {
            background-color: #2a2a2a !important;
        }

        /* Footer */
        footer {
            background-color: #1a1a1a !important;
            color: #9ca3af !important;
            border-top: 1px solid #404040 !important;
            text-align: center !important;
            padding: 20px !important;
        }

        /* Remove horizontal scrollbar and white borders */
        * {
            box-sizing: border-box !important;
        }
    </style>
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">README</a></h2><h3>Tutorials</h3><ul><li><a href="tutorial-build-guide.html">Build Guide</a></li><li><a href="tutorial-installation-guide.html">Installation Guide</a></li></ul><h3>Classes</h3><ul><li><a href="module-server_chatbot-ChatBot.html">ChatBot</a><ul class='methods'><li data-type='method'><a href="module-server_chatbot-ChatBot.html#executeCommand">executeCommand</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#findCustomCommand">findCustomCommand</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#generateForecastText">generateForecastText</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#getDefaultChatBotObject">getDefaultChatBotObject</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#handleForecastCommand">handleForecastCommand</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#handleHelpCommand">handleHelpCommand</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#initialize">initialize</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#isCommandAllowedInChannel">isCommandAllowedInChannel</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#isOnCooldown">isOnCooldown</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#loadSettings">loadSettings</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#mapChatBotObjectToFlatSettings">mapChatBotObjectToFlatSettings</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#mapSettingsToChatBotObject">mapSettingsToChatBotObject</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#processAllianceMessage">processAllianceMessage</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#processPrivateMessage">processPrivateMessage</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#resolveCommandName">resolveCommandName</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#scheduleDailyForecast">scheduleDailyForecast</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#sendAllianceMessage">sendAllianceMessage</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#sendDailyForecast">sendDailyForecast</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#sendErrorMessage">sendErrorMessage</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#sendPrivateMessage">sendPrivateMessage</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#sendResponse">sendResponse</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#setupScheduledTasks">setupScheduledTasks</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#updateCooldown">updateCooldown</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#updateSettings">updateSettings</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#validateCommandArguments">validateCommandArguments</a></li><li data-type='method'><a href="module-server_chatbot-ChatBot.html#validateForecastArguments">validateForecastArguments</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-api.html">api</a><ul class='methods'><li data-type='method'><a href="module-api.html#.activateCampaign">activateCampaign</a></li><li data-type='method'><a href="module-api.html#.deleteChat">deleteChat</a></li><li data-type='method'><a href="module-api.html#.departAllVessels">departAllVessels</a></li><li data-type='method'><a href="module-api.html#.departVessel">departVessel</a></li><li data-type='method'><a href="module-api.html#.departVessels">departVessels</a></li><li data-type='method'><a href="module-api.html#.doWearMaintenanceBulk">doWearMaintenanceBulk</a></li><li data-type='method'><a href="module-api.html#.fetchAcquirableVessels">fetchAcquirableVessels</a></li><li data-type='method'><a href="module-api.html#.fetchAllianceMembers">fetchAllianceMembers</a></li><li data-type='method'><a href="module-api.html#.fetchAssignedPorts">fetchAssignedPorts</a></li><li data-type='method'><a href="module-api.html#.fetchBunkerPrices">fetchBunkerPrices</a></li><li data-type='method'><a href="module-api.html#.fetchCampaigns">fetchCampaigns</a></li><li data-type='method'><a href="module-api.html#.fetchChat">fetchChat</a></li><li data-type='method'><a href="module-api.html#.fetchContacts">fetchContacts</a></li><li data-type='method'><a href="module-api.html#.fetchMessengerChats">fetchMessengerChats</a></li><li data-type='method'><a href="module-api.html#.fetchMessengerMessages">fetchMessengerMessages</a></li><li data-type='method'><a href="module-api.html#.fetchUserCompany">fetchUserCompany</a></li><li data-type='method'><a href="module-api.html#.fetchUserSettings">fetchUserSettings</a></li><li data-type='method'><a href="module-api.html#.fetchVessels">fetchVessels</a></li><li data-type='method'><a href="module-api.html#.getCompanyNameCached">getCompanyNameCached</a></li><li data-type='method'><a href="module-api.html#.getMaintenanceCost">getMaintenanceCost</a></li><li data-type='method'><a href="module-api.html#.markChatAsRead">markChatAsRead</a></li><li data-type='method'><a href="module-api.html#.purchaseCO2">purchaseCO2</a></li><li data-type='method'><a href="module-api.html#.purchaseFuel">purchaseFuel</a></li><li data-type='method'><a href="module-api.html#.purchaseVessel">purchaseVessel</a></li><li data-type='method'><a href="module-api.html#.searchUsers">searchUsers</a></li><li data-type='method'><a href="module-api.html#.sendChatMessage">sendChatMessage</a></li><li data-type='method'><a href="module-api.html#.sendPrivateMessage">sendPrivateMessage</a></li></ul></li><li><a href="module-app.html">app</a></li><li><a href="module-automation.html">automation</a><ul class='methods'><li data-type='method'><a href="module-automation.html#.initAutomation">initAutomation</a></li><li data-type='method'><a href="module-automation.html#.runAutomationChecks">runAutomationChecks</a></li><li data-type='method'><a href="module-automation.html#.triggerAutoRebuyChecks">triggerAutoRebuyChecks</a></li><li data-type='method'><a href="module-automation.html#~calculateRemainingDemand">calculateRemainingDemand</a></li><li data-type='method'><a href="module-automation.html#~checkAutoCampaignRenewal">checkAutoCampaignRenewal</a></li><li data-type='method'><a href="module-automation.html#~checkAutoDepartAll">checkAutoDepartAll</a></li><li data-type='method'><a href="module-automation.html#~checkAutoRebuyCO2">checkAutoRebuyCO2</a></li><li data-type='method'><a href="module-automation.html#~checkAutoRebuyFuel">checkAutoRebuyFuel</a></li><li data-type='method'><a href="module-automation.html#~getTotalCapacity">getTotalCapacity</a></li><li data-type='method'><a href="module-automation.html#~performAutoRebuyCO2">performAutoRebuyCO2</a></li><li data-type='method'><a href="module-automation.html#~performAutoRebuyFuel">performAutoRebuyFuel</a></li><li data-type='method'><a href="module-automation.html#~sendAutoPilotFeedback">sendAutoPilotFeedback</a></li><li data-type='method'><a href="module-automation.html#~showCenterAlert">showCenterAlert</a></li><li data-type='method'><a href="module-automation.html#~updateAutoDepartLabel">updateAutoDepartLabel</a></li></ul></li><li><a href="module-bunker-management.html">bunker-management</a><ul class='methods'><li data-type='method'><a href="module-bunker-management.html#.buyMaxCO2">buyMaxCO2</a></li><li data-type='method'><a href="module-bunker-management.html#.buyMaxFuel">buyMaxFuel</a></li><li data-type='method'><a href="module-bunker-management.html#.getCurrentBunkerState">getCurrentBunkerState</a></li><li data-type='method'><a href="module-bunker-management.html#.setCapacityFromBunkerUpdate">setCapacityFromBunkerUpdate</a></li><li data-type='method'><a href="module-bunker-management.html#.updateBunkerStatus">updateBunkerStatus</a></li><li data-type='method'><a href="module-bunker-management.html#.updateCampaignsStatus">updateCampaignsStatus</a></li><li data-type='method'><a href="module-bunker-management.html#.updateCurrentCO2">updateCurrentCO2</a></li><li data-type='method'><a href="module-bunker-management.html#.updateCurrentCash">updateCurrentCash</a></li><li data-type='method'><a href="module-bunker-management.html#.updateCurrentFuel">updateCurrentFuel</a></li><li data-type='method'><a href="module-bunker-management.html#~retryFetchPrices">retryFetchPrices</a></li></ul></li><li><a href="module-chat.html">chat</a><ul class='methods'><li data-type='method'><a href="module-chat.html#.displayMessages">displayMessages</a></li><li data-type='method'><a href="module-chat.html#.handleMessageInput">handleMessageInput</a></li><li data-type='method'><a href="module-chat.html#.initWebSocket">initWebSocket</a></li><li data-type='method'><a href="module-chat.html#.loadAllianceMembers">loadAllianceMembers</a></li><li data-type='method'><a href="module-chat.html#.loadMessages">loadMessages</a></li><li data-type='method'><a href="module-chat.html#.parseMessageWithMentions">parseMessageWithMentions</a></li><li data-type='method'><a href="module-chat.html#.sendMessage">sendMessage</a></li><li data-type='method'><a href="module-chat.html#.setChatScrollListener">setChatScrollListener</a></li><li data-type='method'><a href="module-chat.html#~attemptReconnect">attemptReconnect</a></li><li data-type='method'><a href="module-chat.html#~displaySuggestions">displaySuggestions</a></li><li data-type='method'><a href="module-chat.html#~formatLocalTime">formatLocalTime</a></li><li data-type='method'><a href="module-chat.html#~handleAnchorUpdate">handleAnchorUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleAutoCoopComplete">handleAutoCoopComplete</a></li><li data-type='method'><a href="module-chat.html#~handleAutoCoopNoTargets">handleAutoCoopNoTargets</a></li><li data-type='method'><a href="module-chat.html#~handleAutopilotDepartStart">handleAutopilotDepartStart</a></li><li data-type='method'><a href="module-chat.html#~handleBackendAutoRepairComplete">handleBackendAutoRepairComplete</a></li><li data-type='method'><a href="module-chat.html#~handleBunkerUpdate">handleBunkerUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleCO2Purchased">handleCO2Purchased</a></li><li data-type='method'><a href="module-chat.html#~handleCampaignStatusUpdate">handleCampaignStatusUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleCampaignsRenewed">handleCampaignsRenewed</a></li><li data-type='method'><a href="module-chat.html#~handleCoopUpdate">handleCoopUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleFuelPurchased">handleFuelPurchased</a></li><li data-type='method'><a href="module-chat.html#~handleGenericNotification">handleGenericNotification</a></li><li data-type='method'><a href="module-chat.html#~handleHeaderDataUpdate">handleHeaderDataUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleHijackingUpdate">handleHijackingUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleMentionAutocomplete">handleMentionAutocomplete</a></li><li data-type='method'><a href="module-chat.html#~handleMessengerUpdate">handleMessengerUpdate</a></li><li data-type='method'><a href="module-chat.html#~handlePriceAlert">handlePriceAlert</a></li><li data-type='method'><a href="module-chat.html#~handlePriceUpdate">handlePriceUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleRepairCountUpdate">handleRepairCountUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleUnreadMessagesUpdate">handleUnreadMessagesUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleUserActionNotification">handleUserActionNotification</a></li><li data-type='method'><a href="module-chat.html#~handleVesselCountUpdate">handleVesselCountUpdate</a></li><li data-type='method'><a href="module-chat.html#~handleVesselsDepartComplete">handleVesselsDepartComplete</a></li><li data-type='method'><a href="module-chat.html#~handleVesselsDeparted">handleVesselsDeparted</a></li><li data-type='method'><a href="module-chat.html#~handleVesselsFailed">handleVesselsFailed</a></li><li data-type='method'><a href="module-chat.html#~handleVesselsRepaired">handleVesselsRepaired</a></li><li data-type='method'><a href="module-chat.html#~hideMemberSuggestions">hideMemberSuggestions</a></li><li data-type='method'><a href="module-chat.html#~insertMention">insertMention</a></li><li data-type='method'><a href="module-chat.html#~registerUsernameClickEvents">registerUsernameClickEvents</a></li></ul></li><li><a href="module-coop.html">coop</a><ul class='methods'><li data-type='method'><a href="module-coop.html#.closeCoopOverlay">closeCoopOverlay</a></li><li data-type='method'><a href="module-coop.html#.fetchCoopData">fetchCoopData</a></li><li data-type='method'><a href="module-coop.html#.sendCoopMax">sendCoopMax</a></li><li data-type='method'><a href="module-coop.html#.showCoopOverlay">showCoopOverlay</a></li><li data-type='method'><a href="module-coop.html#.updateCoopBadge">updateCoopBadge</a></li><li data-type='method'><a href="module-coop.html#~renderMemberCard">renderMemberCard</a></li></ul></li><li><a href="module-desktop-notification-templates.html">desktop-notification-templates</a><ul class='methods'><li data-type='method'><a href="module-desktop-notification-templates.html#.createDesktopNotification">createDesktopNotification</a></li><li data-type='method'><a href="module-desktop-notification-templates.html#.getDefaultEmoji">getDefaultEmoji</a></li><li data-type='method'><a href="module-desktop-notification-templates.html#.getNotificationTypes">getNotificationTypes</a></li><li data-type='method'><a href="module-desktop-notification-templates.html#.isValidNotificationType">isValidNotificationType</a></li><li data-type='method'><a href="module-desktop-notification-templates.html#.notifyAlert">notifyAlert</a></li><li data-type='method'><a href="module-desktop-notification-templates.html#.notifyError">notifyError</a></li><li data-type='method'><a href="module-desktop-notification-templates.html#.notifySuccess">notifySuccess</a></li><li data-type='method'><a href="module-desktop-notification-templates.html#.notifyWarning">notifyWarning</a></li></ul></li><li><a href="module-event-info.html">event-info</a><ul class='methods'><li data-type='method'><a href="module-event-info.html#.initEventInfo">initEventInfo</a></li><li data-type='method'><a href="module-event-info.html#.openEventModal">openEventModal</a></li><li data-type='method'><a href="module-event-info.html#.updateEventData">updateEventData</a></li><li data-type='method'><a href="module-event-info.html#~startEventTimer">startEventTimer</a></li></ul></li><li><a href="module-forecast-calendar.html">forecast-calendar</a><ul class='methods'><li data-type='method'><a href="module-forecast-calendar.html#.initForecastCalendar">initForecastCalendar</a></li><li data-type='method'><a href="module-forecast-calendar.html#.updateEventDiscount">updateEventDiscount</a></li><li data-type='method'><a href="module-forecast-calendar.html#~createTableHTML">createTableHTML</a></li><li data-type='method'><a href="module-forecast-calendar.html#~formatDate">formatDate</a></li><li data-type='method'><a href="module-forecast-calendar.html#~getBrowserTimezone">getBrowserTimezone</a></li><li data-type='method'><a href="module-forecast-calendar.html#~getCo2Class">getCo2Class</a></li><li data-type='method'><a href="module-forecast-calendar.html#~getCurrentVisibleDay">getCurrentVisibleDay</a></li><li data-type='method'><a href="module-forecast-calendar.html#~getFuelClass">getFuelClass</a></li><li data-type='method'><a href="module-forecast-calendar.html#~isEventActiveAtTime">isEventActiveAtTime</a></li><li data-type='method'><a href="module-forecast-calendar.html#~isEventActiveOnDay">isEventActiveOnDay</a></li><li data-type='method'><a href="module-forecast-calendar.html#~loadForecastData">loadForecastData</a></li><li data-type='method'><a href="module-forecast-calendar.html#~preloadMonth">preloadMonth</a></li><li data-type='method'><a href="module-forecast-calendar.html#~renderBook">renderBook</a></li><li data-type='method'><a href="module-forecast-calendar.html#~updateEventBadge">updateEventBadge</a></li></ul></li><li><a href="module-messenger.html">messenger</a><ul class='methods'><li data-type='method'><a href="module-messenger.html#.closeAllChats">closeAllChats</a></li><li data-type='method'><a href="module-messenger.html#.closeChatSelection">closeChatSelection</a></li><li data-type='method'><a href="module-messenger.html#.openMessenger">openMessenger</a></li><li data-type='method'><a href="module-messenger.html#.openNewChat">openNewChat</a></li><li data-type='method'><a href="module-messenger.html#.showAllChats">showAllChats</a></li><li data-type='method'><a href="module-messenger.html#.updateUnreadBadge">updateUnreadBadge</a></li><li data-type='method'><a href="module-messenger.html#~formatTimestamp">formatTimestamp</a></li><li data-type='method'><a href="module-messenger.html#~loadPrivateMessages">loadPrivateMessages</a></li><li data-type='method'><a href="module-messenger.html#~startHijackingPolling">startHijackingPolling</a></li><li data-type='method'><a href="module-messenger.html#~stopHijackingPolling">stopHijackingPolling</a></li></ul></li><li><a href="module-public_js_modules_hijacking.html">public/js/modules/hijacking</a><ul class='methods'><li data-type='method'><a href="module-public_js_modules_hijacking.html#.closeHijackingInbox">closeHijackingInbox</a></li><li data-type='method'><a href="module-public_js_modules_hijacking.html#.openHijackingInbox">openHijackingInbox</a></li><li data-type='method'><a href="module-public_js_modules_hijacking.html#.updateHijackedVesselsDisplay">updateHijackedVesselsDisplay</a></li><li data-type='method'><a href="module-public_js_modules_hijacking.html#.updateHijackingBadge">updateHijackingBadge</a></li><li data-type='method'><a href="module-public_js_modules_hijacking.html#~deleteCase">deleteCase</a></li><li data-type='method'><a href="module-public_js_modules_hijacking.html#~escapeHtml">escapeHtml</a></li><li data-type='method'><a href="module-public_js_modules_hijacking.html#~formatTimestamp">formatTimestamp</a></li><li data-type='method'><a href="module-public_js_modules_hijacking.html#~openCaseDetails">openCaseDetails</a></li><li data-type='method'><a href="module-public_js_modules_hijacking.html#~refreshHijackingBadge">refreshHijackingBadge</a></li><li data-type='method'><a href="module-public_js_modules_hijacking.html#~renderCaseList">renderCaseList</a></li></ul></li><li><a href="module-server_automation.html">server/automation</a><ul class='methods'><li data-type='method'><a href="module-server_automation.html#~getRandomInterval">getRandomInterval</a></li><li data-type='method'><a href="module-server_automation.html#~initialize">initialize</a></li><li data-type='method'><a href="module-server_automation.html#~loadSettings">loadSettings</a></li><li data-type='method'><a href="module-server_automation.html#~parseInterval">parseInterval</a></li><li data-type='method'><a href="module-server_automation.html#~restartAutoRepair">restartAutoRepair</a></li><li data-type='method'><a href="module-server_automation.html#~runAutoRepair">runAutoRepair</a></li><li data-type='method'><a href="module-server_automation.html#~scheduleAutoRepair">scheduleAutoRepair</a></li></ul></li><li><a href="module-server_autopilot.html">server/autopilot</a><ul class='methods'><li data-type='method'><a href="module-server_autopilot.html#~acceptRansomWithRetry">acceptRansomWithRetry</a></li><li data-type='method'><a href="module-server_autopilot.html#~analyzeVesselDepartures">analyzeVesselDepartures</a></li><li data-type='method'><a href="module-server_autopilot.html#~autoAnchorPointPurchase">autoAnchorPointPurchase</a></li><li data-type='method'><a href="module-server_autopilot.html#~autoCampaignRenewal">autoCampaignRenewal</a></li><li data-type='method'><a href="module-server_autopilot.html#~autoCoop">autoCoop</a></li><li data-type='method'><a href="module-server_autopilot.html#~autoDepartVessels">autoDepartVessels</a></li><li data-type='method'><a href="module-server_autopilot.html#~autoNegotiateHijacking">autoNegotiateHijacking</a></li><li data-type='method'><a href="module-server_autopilot.html#~autoRebuyAll">autoRebuyAll</a></li><li data-type='method'><a href="module-server_autopilot.html#~autoRebuyCO2">autoRebuyCO2</a></li><li data-type='method'><a href="module-server_autopilot.html#~autoRebuyFuel">autoRebuyFuel</a></li><li data-type='method'><a href="module-server_autopilot.html#~autoRepairVessels">autoRepairVessels</a></li><li data-type='method'><a href="module-server_autopilot.html#~calculatePendingAnchorPoints">calculatePendingAnchorPoints</a></li><li data-type='method'><a href="module-server_autopilot.html#~calculateRemainingDemand">calculateRemainingDemand</a></li><li data-type='method'><a href="module-server_autopilot.html#~checkPriceAlerts">checkPriceAlerts</a></li><li data-type='method'><a href="module-server_autopilot.html#~countActiveCampaignTypes">countActiveCampaignTypes</a></li><li data-type='method'><a href="module-server_autopilot.html#~departVessels">departVessels</a></li><li data-type='method'><a href="module-server_autopilot.html#~fetchAllianceDataCached">fetchAllianceDataCached</a></li><li data-type='method'><a href="module-server_autopilot.html#~fetchCoopDataCached">fetchCoopDataCached</a></li><li data-type='method'><a href="module-server_autopilot.html#~getCachedCapacity">getCachedCapacity</a></li><li data-type='method'><a href="module-server_autopilot.html#~getCaseWithRetry">getCaseWithRetry</a></li><li data-type='method'><a href="module-server_autopilot.html#~getTotalCapacity">getTotalCapacity</a></li><li data-type='method'><a href="module-server_autopilot.html#~initializeAutopilotState">initializeAutopilotState</a></li><li data-type='method'><a href="module-server_autopilot.html#~isAutopilotPaused">isAutopilotPaused</a></li><li data-type='method'><a href="module-server_autopilot.html#~mainEventLoop">mainEventLoop</a></li><li data-type='method'><a href="module-server_autopilot.html#~pauseAutopilot">pauseAutopilot</a></li><li data-type='method'><a href="module-server_autopilot.html#~processHijackingCase">processHijackingCase</a></li><li data-type='method'><a href="module-server_autopilot.html#~refreshHijackingBadge">refreshHijackingBadge</a></li><li data-type='method'><a href="module-server_autopilot.html#~resumeAutopilot">resumeAutopilot</a></li><li data-type='method'><a href="module-server_autopilot.html#~setBroadcastFunction">setBroadcastFunction</a></li><li data-type='method'><a href="module-server_autopilot.html#~startMainEventLoop">startMainEventLoop</a></li><li data-type='method'><a href="module-server_autopilot.html#~submitOfferWithRetry">submitOfferWithRetry</a></li><li data-type='method'><a href="module-server_autopilot.html#~tryUpdateAllData">tryUpdateAllData</a></li><li data-type='method'><a href="module-server_autopilot.html#~updateAllData">updateAllData</a></li><li data-type='method'><a href="module-server_autopilot.html#~updateCampaigns">updateCampaigns</a></li><li data-type='method'><a href="module-server_autopilot.html#~updatePrices">updatePrices</a></li><li data-type='method'><a href="module-server_autopilot.html#~updateRepairCount">updateRepairCount</a></li><li data-type='method'><a href="module-server_autopilot.html#~updateUnreadMessages">updateUnreadMessages</a></li><li data-type='method'><a href="module-server_autopilot.html#~updateVesselCount">updateVesselCount</a></li></ul></li><li><a href="module-server_cache.html">server/cache</a><ul class='methods'><li data-type='method'><a href="module-server_cache.html#~clearAllCaches">clearAllCaches</a></li><li data-type='method'><a href="module-server_cache.html#~getAllianceCache">getAllianceCache</a></li><li data-type='method'><a href="module-server_cache.html#~getCampaignCache">getCampaignCache</a></li><li data-type='method'><a href="module-server_cache.html#~getCompanyCache">getCompanyCache</a></li><li data-type='method'><a href="module-server_cache.html#~getCoopCache">getCoopCache</a></li><li data-type='method'><a href="module-server_cache.html#~invalidateCampaignCache">invalidateCampaignCache</a></li><li data-type='method'><a href="module-server_cache.html#~invalidateCoopCache">invalidateCoopCache</a></li><li data-type='method'><a href="module-server_cache.html#~isCacheValid">isCacheValid</a></li><li data-type='method'><a href="module-server_cache.html#~setAllianceCache">setAllianceCache</a></li><li data-type='method'><a href="module-server_cache.html#~setCampaignCache">setCampaignCache</a></li><li data-type='method'><a href="module-server_cache.html#~setCompanyCache">setCompanyCache</a></li><li data-type='method'><a href="module-server_cache.html#~setCoopCache">setCoopCache</a></li></ul></li><li><a href="module-server_certificate.html">server/certificate</a><ul class='methods'><li data-type='method'><a href="module-server_certificate.html#~createHttpsServer">createHttpsServer</a></li><li data-type='method'><a href="module-server_certificate.html#~generateCA">generateCA</a></li><li data-type='method'><a href="module-server_certificate.html#~generateCertificate">generateCertificate</a></li><li data-type='method'><a href="module-server_certificate.html#~getNetworkIPs">getNetworkIPs</a></li><li data-type='method'><a href="module-server_certificate.html#~isCertificateInstalled">isCertificateInstalled</a></li><li data-type='method'><a href="module-server_certificate.html#~loadCertificate">loadCertificate</a></li></ul></li><li><a href="module-server_chatbot.html">server/chatbot</a></li><li><a href="module-server_config.html">server/config</a><ul class='methods'><li data-type='method'><a href="module-server_config.html#~getAppDataDir">getAppDataDir</a></li><li data-type='method'><a href="module-server_config.html#~getLocalAppDataDir">getLocalAppDataDir</a></li><li data-type='method'><a href="module-server_config.html#~getLogDir">getLogDir</a></li><li data-type='method'><a href="module-server_config.html#~getSessionCookie">getSessionCookie</a></li><li data-type='method'><a href="module-server_config.html#~getSettingsDir">getSettingsDir</a></li><li data-type='method'><a href="module-server_config.html#~loadStartupSettings">loadStartupSettings</a></li><li data-type='method'><a href="module-server_config.html#~setSessionCookie">setSessionCookie</a></li></ul></li><li><a href="module-server_gameapi.html">server/gameapi</a><ul class='methods'><li data-type='method'><a href="module-server_gameapi.html#~activateCampaign">activateCampaign</a></li><li data-type='method'><a href="module-server_gameapi.html#~bulkRepairVessels">bulkRepairVessels</a></li><li data-type='method'><a href="module-server_gameapi.html#~departVessel">departVessel</a></li><li data-type='method'><a href="module-server_gameapi.html#~fetchAssignedPorts">fetchAssignedPorts</a></li><li data-type='method'><a href="module-server_gameapi.html#~fetchAutoPrice">fetchAutoPrice</a></li><li data-type='method'><a href="module-server_gameapi.html#~fetchBunkerState">fetchBunkerState</a></li><li data-type='method'><a href="module-server_gameapi.html#~fetchCampaigns">fetchCampaigns</a></li><li data-type='method'><a href="module-server_gameapi.html#~fetchEventData">fetchEventData</a></li><li data-type='method'><a href="module-server_gameapi.html#~fetchPrices">fetchPrices</a></li><li data-type='method'><a href="module-server_gameapi.html#~fetchRepairCount">fetchRepairCount</a></li><li data-type='method'><a href="module-server_gameapi.html#~fetchUnreadMessages">fetchUnreadMessages</a></li><li data-type='method'><a href="module-server_gameapi.html#~fetchVessels">fetchVessels</a></li><li data-type='method'><a href="module-server_gameapi.html#~getMaintenanceCost">getMaintenanceCost</a></li><li data-type='method'><a href="module-server_gameapi.html#~purchaseCO2">purchaseCO2</a></li><li data-type='method'><a href="module-server_gameapi.html#~purchaseFuel">purchaseFuel</a></li></ul></li><li><a href="module-server_middleware_index.html">server/middleware/index</a><ul class='methods'><li data-type='method'><a href="module-server_middleware_index.html#~setupMiddleware">setupMiddleware</a></li></ul></li><li><a href="module-server_routes_alliance.html">server/routes/alliance</a><ul class='methods'><li data-type='method'><a href="module-server_routes_alliance.html#.GET/api/alliance-members">GET /api/alliance-members</a></li><li data-type='method'><a href="module-server_routes_alliance.html#.GET/api/chat">GET /api/chat</a></li><li data-type='method'><a href="module-server_routes_alliance.html#.POST/api/company-name">POST /api/company-name</a></li><li data-type='method'><a href="module-server_routes_alliance.html#.POST/api/send-message">POST /api/send-message</a></li></ul></li><li><a href="module-server_routes_anchor.html">server/routes/anchor</a></li><li><a href="module-server_routes_coop.html">server/routes/coop</a><ul class='methods'><li data-type='method'><a href="module-server_routes_coop.html#.GET/api/coop/data">GET /api/coop/data</a></li><li data-type='method'><a href="module-server_routes_coop.html#.POST/api/coop/send-max">POST /api/coop/send-max</a></li></ul></li><li><a href="module-server_routes_forecast.html">server/routes/forecast</a><ul class='methods'><li data-type='method'><a href="module-server_routes_forecast.html#~convertCESTToTimezone">convertCESTToTimezone</a></li><li data-type='method'><a href="module-server_routes_forecast.html#~generateChatbotText">generateChatbotText</a></li><li data-type='method'><a href="module-server_routes_forecast.html#~generateMetadata">generateMetadata</a></li><li data-type='method'><a href="module-server_routes_forecast.html#~getForecastDataPath">getForecastDataPath</a></li><li data-type='method'><a href="module-server_routes_forecast.html#~getNextDayData">getNextDayData</a></li><li data-type='method'><a href="module-server_routes_forecast.html#~getPreviousDayData">getPreviousDayData</a></li><li data-type='method'><a href="module-server_routes_forecast.html#~getServerLocalTimezone">getServerLocalTimezone</a></li><li data-type='method'><a href="module-server_routes_forecast.html#~getTimezoneOffsetHours">getTimezoneOffsetHours</a></li><li data-type='method'><a href="module-server_routes_forecast.html#~getValidTimezones">getValidTimezones</a></li></ul></li><li><a href="module-server_routes_game.html">server/routes/game</a></li><li><a href="module-server_routes_health.html">server/routes/health</a></li><li><a href="module-server_routes_messenger.html">server/routes/messenger</a><ul class='methods'><li data-type='method'><a href="module-server_routes_messenger.html#.GET/api/contact/get-contacts">GET /api/contact/get-contacts</a></li><li data-type='method'><a href="module-server_routes_messenger.html#.GET/api/hijacking/get-cases">GET /api/hijacking/get-cases</a></li><li data-type='method'><a href="module-server_routes_messenger.html#.GET/api/messenger/get-chats">GET /api/messenger/get-chats</a></li><li data-type='method'><a href="module-server_routes_messenger.html#.POST/api/messenger/delete-chat">POST /api/messenger/delete-chat</a></li><li data-type='method'><a href="module-server_routes_messenger.html#.POST/api/messenger/get-messages">POST /api/messenger/get-messages</a></li><li data-type='method'><a href="module-server_routes_messenger.html#.POST/api/messenger/send-private">POST /api/messenger/send-private</a></li><li data-type='method'><a href="module-server_routes_messenger.html#.POST/api/user/search">POST /api/user/search</a></li><li data-type='method'><a href="module-server_routes_messenger.html#~migrateHijackHistory">migrateHijackHistory</a></li></ul></li><li><a href="module-server_routes_settings.html">server/routes/settings</a><ul class='methods'><li data-type='method'><a href="module-server_routes_settings.html#.GET/api/settings">GET /api/settings</a></li><li data-type='method'><a href="module-server_routes_settings.html#.POST/api/settings">POST /api/settings</a></li></ul></li><li><a href="module-server_scheduler.html">server/scheduler</a><ul class='methods'><li data-type='method'><a href="module-server_scheduler.html#~initScheduler">initScheduler</a></li><li data-type='method'><a href="module-server_scheduler.html#~isServerReady">isServerReady</a></li></ul></li><li><a href="module-server_settings-schema.html">server/settings-schema</a><ul class='methods'><li data-type='method'><a href="module-server_settings-schema.html#~getDefault">getDefault</a></li><li data-type='method'><a href="module-server_settings-schema.html#~getDefaults">getDefaults</a></li><li data-type='method'><a href="module-server_settings-schema.html#~getRequiredKeys">getRequiredKeys</a></li><li data-type='method'><a href="module-server_settings-schema.html#~getSettingsFilePath">getSettingsFilePath</a></li><li data-type='method'><a href="module-server_settings-schema.html#~initializeSettings">initializeSettings</a></li><li data-type='method'><a href="module-server_settings-schema.html#~saveSettings">saveSettings</a></li><li data-type='method'><a href="module-server_settings-schema.html#~validateSettings">validateSettings</a></li><li data-type='method'><a href="module-server_settings-schema.html#~validateValue">validateValue</a></li></ul></li><li><a href="module-server_state.html">server/state</a><ul class='methods'><li data-type='method'><a href="module-server_state.html#~getAutopilotState">getAutopilotState</a></li><li data-type='method'><a href="module-server_state.html#~getBunkerState">getBunkerState</a></li><li data-type='method'><a href="module-server_state.html#~getCampaignStatus">getCampaignStatus</a></li><li data-type='method'><a href="module-server_state.html#~getCoopData">getCoopData</a></li><li data-type='method'><a href="module-server_state.html#~getEventData">getEventData</a></li><li data-type='method'><a href="module-server_state.html#~getHeaderData">getHeaderData</a></li><li data-type='method'><a href="module-server_state.html#~getLastCO2Alert">getLastCO2Alert</a></li><li data-type='method'><a href="module-server_state.html#~getLastFuelAlert">getLastFuelAlert</a></li><li data-type='method'><a href="module-server_state.html#~getPrices">getPrices</a></li><li data-type='method'><a href="module-server_state.html#~getRepairCount">getRepairCount</a></li><li data-type='method'><a href="module-server_state.html#~getSettings">getSettings</a></li><li data-type='method'><a href="module-server_state.html#~getUserState">getUserState</a></li><li data-type='method'><a href="module-server_state.html#~getVesselCounts">getVesselCounts</a></li><li data-type='method'><a href="module-server_state.html#~isAutopilotPaused">isAutopilotPaused</a></li><li data-type='method'><a href="module-server_state.html#~setAutopilotPaused">setAutopilotPaused</a></li><li data-type='method'><a href="module-server_state.html#~setAutopilotState">setAutopilotState</a></li><li data-type='method'><a href="module-server_state.html#~setLastCO2Alert">setLastCO2Alert</a></li><li data-type='method'><a href="module-server_state.html#~setLastFuelAlert">setLastFuelAlert</a></li><li data-type='method'><a href="module-server_state.html#~updateBunkerState">updateBunkerState</a></li><li data-type='method'><a href="module-server_state.html#~updateCampaignStatus">updateCampaignStatus</a></li><li data-type='method'><a href="module-server_state.html#~updateCoopData">updateCoopData</a></li><li data-type='method'><a href="module-server_state.html#~updateEventData">updateEventData</a></li><li data-type='method'><a href="module-server_state.html#~updateHeaderData">updateHeaderData</a></li><li data-type='method'><a href="module-server_state.html#~updatePrices">updatePrices</a></li><li data-type='method'><a href="module-server_state.html#~updateRepairCount">updateRepairCount</a></li><li data-type='method'><a href="module-server_state.html#~updateSettings">updateSettings</a></li><li data-type='method'><a href="module-server_state.html#~updateVesselCounts">updateVesselCounts</a></li></ul></li><li><a href="module-server_utils_api.html">server/utils/api</a><ul class='methods'><li data-type='method'><a href="module-server_utils_api.html#~apiCall">apiCall</a></li><li data-type='method'><a href="module-server_utils_api.html#~apiCallWithRetry">apiCallWithRetry</a></li><li data-type='method'><a href="module-server_utils_api.html#~getAllianceId">getAllianceId</a></li><li data-type='method'><a href="module-server_utils_api.html#~getChatFeed">getChatFeed</a></li><li data-type='method'><a href="module-server_utils_api.html#~getCompanyName">getCompanyName</a></li><li data-type='method'><a href="module-server_utils_api.html#~getUserCompanyName">getUserCompanyName</a></li><li data-type='method'><a href="module-server_utils_api.html#~getUserId">getUserId</a></li><li data-type='method'><a href="module-server_utils_api.html#~initializeAlliance">initializeAlliance</a></li><li data-type='method'><a href="module-server_utils_api.html#~sleep">sleep</a></li></ul></li><li><a href="module-server_utils_encryption.html">server/utils/encryption</a><ul class='methods'><li data-type='method'><a href="module-server_utils_encryption.html#~decryptData">decryptData</a></li><li data-type='method'><a href="module-server_utils_encryption.html#~deleteEncryptedData">deleteEncryptedData</a></li><li data-type='method'><a href="module-server_utils_encryption.html#~encryptData">encryptData</a></li><li data-type='method'><a href="module-server_utils_encryption.html#~getEncryptionInfo">getEncryptionInfo</a></li><li data-type='method'><a href="module-server_utils_encryption.html#~getMachineKey">getMachineKey</a></li><li data-type='method'><a href="module-server_utils_encryption.html#~isEncrypted">isEncrypted</a></li></ul></li><li><a href="module-server_utils_logger.html">server/utils/logger</a><ul class='methods'><li data-type='method'><a href="module-server_utils_logger.html#~debug">debug</a></li><li data-type='method'><a href="module-server_utils_logger.html#~error">error</a></li><li data-type='method'><a href="module-server_utils_logger.html#~isDebugMode">isDebugMode</a></li><li data-type='method'><a href="module-server_utils_logger.html#~loadLogLevel">loadLogLevel</a></li><li data-type='method'><a href="module-server_utils_logger.html#~log">log</a></li><li data-type='method'><a href="module-server_utils_logger.html#~warn">warn</a></li></ul></li><li><a href="module-server_utils_session-manager.html">server/utils/session-manager</a><ul class='methods'><li data-type='method'><a href="module-server_utils_session-manager.html#~deleteSession">deleteSession</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~getAllUserIds">getAllUserIds</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~getAvailableSessions">getAvailableSessions</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~getSession">getSession</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~getSessionsPath">getSessionsPath</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~hasSession">hasSession</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~loadAllSessions">loadAllSessions</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~loadSessions">loadSessions</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~migrateToEncrypted">migrateToEncrypted</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~saveSession">saveSession</a></li><li data-type='method'><a href="module-server_utils_session-manager.html#~saveSessions">saveSessions</a></li></ul></li><li><a href="module-server_websocket.html">server/websocket</a><ul class='methods'><li data-type='method'><a href="module-server_websocket.html#~broadcast">broadcast</a></li><li data-type='method'><a href="module-server_websocket.html#~broadcastBunkerUpdate">broadcastBunkerUpdate</a></li><li data-type='method'><a href="module-server_websocket.html#~broadcastToUser">broadcastToUser</a></li><li data-type='method'><a href="module-server_websocket.html#~getCachedHijackingCase">getCachedHijackingCase</a></li><li data-type='method'><a href="module-server_websocket.html#~getCachedMessengerChats">getCachedMessengerChats</a></li><li data-type='method'><a href="module-server_websocket.html#~getProcessedMessageIds">getProcessedMessageIds</a></li><li data-type='method'><a href="module-server_websocket.html#~getProcessedMessagesCachePath">getProcessedMessagesCachePath</a></li><li data-type='method'><a href="module-server_websocket.html#~initWebSocket">initWebSocket</a></li><li data-type='method'><a href="module-server_websocket.html#~loadProcessedMessageCache">loadProcessedMessageCache</a></li><li data-type='method'><a href="module-server_websocket.html#~performChatRefresh">performChatRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~performHijackingRefresh">performHijackingRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~performMessengerRefresh">performMessengerRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~saveProcessedMessageCache">saveProcessedMessageCache</a></li><li data-type='method'><a href="module-server_websocket.html#~startChatAutoRefresh">startChatAutoRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~startChatAutoRefresh">startChatAutoRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~startHijackingAutoRefresh">startHijackingAutoRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~startMessengerAutoRefresh">startMessengerAutoRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~stopChatAutoRefresh">stopChatAutoRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~stopHijackingAutoRefresh">stopHijackingAutoRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~stopMessengerAutoRefresh">stopMessengerAutoRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~triggerImmediateChatRefresh">triggerImmediateChatRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~triggerImmediateHijackingRefresh">triggerImmediateHijackingRefresh</a></li><li data-type='method'><a href="module-server_websocket.html#~triggerImmediateMessengerRefresh">triggerImmediateMessengerRefresh</a></li></ul></li><li><a href="module-ui-dialogs.html">ui-dialogs</a><ul class='methods'><li data-type='method'><a href="module-ui-dialogs.html#.buyCampaign">buyCampaign</a></li><li data-type='method'><a href="module-ui-dialogs.html#.closeCampaignsOverlay">closeCampaignsOverlay</a></li><li data-type='method'><a href="module-ui-dialogs.html#.closeSettings">closeSettings</a></li><li data-type='method'><a href="module-ui-dialogs.html#.showCampaignsOverlay">showCampaignsOverlay</a></li><li data-type='method'><a href="module-ui-dialogs.html#.showConfirmDialog">showConfirmDialog</a></li><li data-type='method'><a href="module-ui-dialogs.html#.showContactList">showContactList</a></li><li data-type='method'><a href="module-ui-dialogs.html#.showSettings">showSettings</a></li></ul></li><li><a href="module-utils.html">utils</a><ul class='methods'><li data-type='method'><a href="module-utils.html#.escapeHtml">escapeHtml</a></li><li data-type='method'><a href="module-utils.html#.formatNumber">formatNumber</a></li><li data-type='method'><a href="module-utils.html#.registerServiceWorker">registerServiceWorker</a></li><li data-type='method'><a href="module-utils.html#.renderStars">renderStars</a></li><li data-type='method'><a href="module-utils.html#.requestNotificationPermission">requestNotificationPermission</a></li><li data-type='method'><a href="module-utils.html#.showNotification">showNotification</a></li><li data-type='method'><a href="module-utils.html#.showSideNotification">showSideNotification</a></li></ul></li><li><a href="module-vessel-management.html">vessel-management</a><ul class='methods'><li data-type='method'><a href="module-vessel-management.html#.departAllVessels">departAllVessels</a></li><li data-type='method'><a href="module-vessel-management.html#.purchaseSingleVessel">purchaseSingleVessel</a></li><li data-type='method'><a href="module-vessel-management.html#.updateVesselCount">updateVesselCount</a></li><li data-type='method'><a href="module-vessel-management.html#~createVesselCard">createVesselCard</a></li><li data-type='method'><a href="module-vessel-management.html#~displayFilteredVessels">displayFilteredVessels</a></li><li data-type='method'><a href="module-vessel-management.html#~getAvailableAnchorSlots">getAvailableAnchorSlots</a></li><li data-type='method'><a href="module-vessel-management.html#~getCO2EfficiencyClass">getCO2EfficiencyClass</a></li><li data-type='method'><a href="module-vessel-management.html#~getCapacityDisplay">getCapacityDisplay</a></li><li data-type='method'><a href="module-vessel-management.html#~getFuelEfficiencyClass">getFuelEfficiencyClass</a></li><li data-type='method'><a href="module-vessel-management.html#~loadMorePendingVessels">loadMorePendingVessels</a></li><li data-type='method'><a href="module-vessel-management.html#~loadMoreVessels">loadMoreVessels</a></li><li data-type='method'><a href="module-vessel-management.html#~populateDynamicFilters">populateDynamicFilters</a></li><li data-type='method'><a href="module-vessel-management.html#~preloadCommonVesselImages">preloadCommonVesselImages</a></li><li data-type='method'><a href="module-vessel-management.html#~preloadVesselImage">preloadVesselImage</a></li><li data-type='method'><a href="module-vessel-management.html#~refreshVesselCardsIfVisible">refreshVesselCardsIfVisible</a></li><li data-type='method'><a href="module-vessel-management.html#~showBulkRepairDialog">showBulkRepairDialog</a></li><li data-type='method'><a href="module-vessel-management.html#~updateCapacityDropdowns">updateCapacityDropdowns</a></li><li data-type='method'><a href="module-vessel-management.html#~vesselPassesFilters">vesselPassesFilters</a></li></ul></li><li><a href="module-vessel-selling.html">vessel-selling</a><ul class='methods'><li data-type='method'><a href="module-vessel-selling.html#.bulkSellVessels">bulkSellVessels</a></li><li data-type='method'><a href="module-vessel-selling.html#.closeSellVesselsOverlay">closeSellVesselsOverlay</a></li><li data-type='method'><a href="module-vessel-selling.html#.openSellVesselsOverlay">openSellVesselsOverlay</a></li><li data-type='method'><a href="module-vessel-selling.html#.setSellFilter">setSellFilter</a></li><li data-type='method'><a href="module-vessel-selling.html#.showSellCart">showSellCart</a></li><li data-type='method'><a href="module-vessel-selling.html#~addVesselsToCart">addVesselsToCart</a></li><li data-type='method'><a href="module-vessel-selling.html#~displaySellVessels">displaySellVessels</a></li><li data-type='method'><a href="module-vessel-selling.html#~getCO2EfficiencyClass">getCO2EfficiencyClass</a></li><li data-type='method'><a href="module-vessel-selling.html#~getCapacityDisplay">getCapacityDisplay</a></li><li data-type='method'><a href="module-vessel-selling.html#~getFuelEfficiencyClass">getFuelEfficiencyClass</a></li><li data-type='method'><a href="module-vessel-selling.html#~groupVesselsByModel">groupVesselsByModel</a></li><li data-type='method'><a href="module-vessel-selling.html#~loadUserVesselsForSale">loadUserVesselsForSale</a></li><li data-type='method'><a href="module-vessel-selling.html#~removeVesselSelectionFromCart">removeVesselSelectionFromCart</a></li><li data-type='method'><a href="module-vessel-selling.html#~sellVessels">sellVessels</a></li><li data-type='method'><a href="module-vessel-selling.html#~toggleVesselSelection">toggleVesselSelection</a></li><li data-type='method'><a href="module-vessel-selling.html#~updateBulkSellButton">updateBulkSellButton</a></li><li data-type='method'><a href="module-vessel-selling.html#~updateSelectButtonState">updateSelectButtonState</a></li><li data-type='method'><a href="module-vessel-selling.html#~updateVesselSelectionInCart">updateVesselSelectionInCart</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#buildNav">buildNav</a></li><li><a href="global.html#express">express</a></li><li><a href="global.html#lockBulkBuyButton">lockBulkBuyButton</a></li><li><a href="global.html#lockCo2Button">lockCo2Button</a></li><li><a href="global.html#lockCoopButtons">lockCoopButtons</a></li><li><a href="global.html#lockDepartButton">lockDepartButton</a></li><li><a href="global.html#lockFuelButton">lockFuelButton</a></li><li><a href="global.html#lockRepairButton">lockRepairButton</a></li><li><a href="global.html#publish">publish</a></li><li><a href="global.html#showAnchorTimer">showAnchorTimer</a></li><li><a href="global.html#unlockBulkBuyButton">unlockBulkBuyButton</a></li><li><a href="global.html#unlockCo2Button">unlockCo2Button</a></li><li><a href="global.html#unlockCoopButtons">unlockCoopButtons</a></li><li><a href="global.html#unlockDepartButton">unlockDepartButton</a></li><li><a href="global.html#unlockFuelButton">unlockFuelButton</a></li><li><a href="global.html#unlockRepairButton">unlockRepairButton</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">server/autopilot.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Autopilot Service
 *
 * Centralized autopilot logic running on the backend.
 * Replaces frontend autopilot to prevent race conditions in multi-tab scenarios.
 *
 * Key Features:
 * - Price updates at fixed times (:01 and :31 every hour)
 * - Auto-rebuy fuel/CO2 with no cooldowns
 * - Intelligent auto-depart with port demand checking
 * - Auto bulk repair
 * - Auto campaign renewal
 * - Price alert detection and broadcasting
 *
 * Important Design Decisions:
 * - NO COOLDOWNS on auto-rebuy (if price good and space available  buy immediately)
 * - Auto-rebuy triggered by: (1) 5-minute timer AND (2) after every auto-depart
 * - Fixed schedule for auto-depart (5, 15, or 30 minute intervals)
 * - All actions broadcast to WebSocket clients for UI updates
 *
 * Single User Design:
 * - One Steam account per server instance
 * - But code structured to support multiple users (future-proofing)
 * - getAllUserIds() returns all active users
 *
 * @module server/autopilot
 */

const gameapi = require('./gameapi');
const state = require('./state');
const cache = require('./cache');
const config = require('./config');
const { getUserId, apiCall } = require('./utils/api');
const logger = require('./utils/logger');
const path = require('path');
const fs = require('fs');
const os = require('os');

// Debug mode - controlled by server/config.js
const DEBUG_MODE = config.DEBUG_MODE;

// WebSocket broadcasting functions (will be injected by websocket.js)
let broadcastToUser = null;

/**
 * Injects WebSocket broadcasting function.
 * Called by websocket.js during initialization.
 *
 * @param {Function} broadcastFn - Function to broadcast events to user
 */
function setBroadcastFunction(broadcastFn) {
  broadcastToUser = broadcastFn;
  logger.log('[Autopilot] Broadcast function set:', broadcastFn ? 'OK' : 'NULL');
}

// Global pause state for all autopilot functions
// NOTE: This is initialized from settings on startup - see initializeAutopilotState()
let autopilotPaused = false;

/**
 * Initializes autopilot pause state from persistent settings.
 * Called once during server startup in scheduler.js
 *
 * @param {number} userId - User ID
 */
function initializeAutopilotState(userId) {
  const settings = state.getSettings(userId);
  if (settings &amp;&amp; typeof settings.autopilotPaused === 'boolean') {
    autopilotPaused = settings.autopilotPaused;
    logger.log(`[Autopilot] Loaded pause state from settings: ${autopilotPaused ? 'PAUSED' : 'RUNNING'}`);
  } else {
    logger.log('[Autopilot] No saved pause state, defaulting to RUNNING');
  }
}

/**
 * Pauses all autopilot functions globally and saves state to settings
 */
async function pauseAutopilot() {
  autopilotPaused = true;
  logger.log('[Autopilot] PAUSED - All autopilot functions suspended');

  // Save pause state to settings (persistent)
  try {
    const { getUserId } = require('./utils/api');
    const userId = getUserId();
    if (userId) {
      const settings = state.getSettings(userId);
      settings.autopilotPaused = true;

      // Write to file
      const { getSettingsFilePath } = require('./settings-schema');
      const fs = require('fs').promises;
      const settingsFile = getSettingsFilePath(userId);
      await fs.writeFile(settingsFile, JSON.stringify(settings, null, 2), 'utf8');
      logger.log('[Autopilot] Pause state saved to settings');
    }
  } catch (error) {
    logger.error('[Autopilot] Failed to save pause state:', error);
  }

  // Broadcast to ALL connected clients, not just the triggering user
  // This ensures all open browser tabs/devices see the pause state
  if (broadcastToUser) {
    // Note: broadcastToUser actually broadcasts to ALL in single-user mode
    // but we use null as userId to make it clear we want ALL clients
    broadcastToUser(null, 'autopilot_status', { paused: true });
  }
}

/**
 * Resumes all autopilot functions globally and saves state to settings
 */
async function resumeAutopilot() {
  autopilotPaused = false;
  logger.log('[Autopilot] RESUMED - All autopilot functions active');

  // Save resume state to settings (persistent)
  try {
    const { getUserId } = require('./utils/api');
    const userId = getUserId();
    if (userId) {
      const settings = state.getSettings(userId);
      settings.autopilotPaused = false;

      // Write to file
      const { getSettingsFilePath } = require('./settings-schema');
      const fs = require('fs').promises;
      const settingsFile = getSettingsFilePath(userId);
      await fs.writeFile(settingsFile, JSON.stringify(settings, null, 2), 'utf8');
      logger.log('[Autopilot] Resume state saved to settings');
    }
  } catch (error) {
    logger.error('[Autopilot] Failed to save resume state:', error);
  }

  // Broadcast to ALL connected clients, not just the triggering user
  // This ensures all open browser tabs/devices see the resume state
  if (broadcastToUser) {
    // Note: broadcastToUser actually broadcasts to ALL in single-user mode
    // but we use null as userId to make it clear we want ALL clients
    broadcastToUser(null, 'autopilot_status', { paused: false });
  }
}

/**
 * Gets current autopilot pause status
 */
function isAutopilotPaused() {
  return autopilotPaused;
}

// ============================================================================
// Price Updates
// ============================================================================

/**
 * Updates market prices for all users.
 * Called by scheduler at :01 and :31 every hour.
 *
 * Fetches current prices from game API, stores in state, and broadcasts to clients.
 * After updating prices, triggers price alert checks.
 */
async function updatePrices() {
  const userId = getUserId();
  if (!userId) {
    logger.log('[Autopilot] No user ID available, skipping price update');
    return;
  }

  try {
    logger.log('[Autopilot] Fetching price update from game API');
    const prices = await gameapi.fetchPrices();

    // Update state with discount info
    state.updatePrices(userId, prices.fuel, prices.co2, prices.eventDiscount, prices.regularFuel, prices.regularCO2);

    if (prices.eventDiscount) {
      logger.log(`[Autopilot] EVENT ACTIVE: ${prices.eventDiscount.percentage}% off ${prices.eventDiscount.type}`);
      logger.log(`[Autopilot] Price update: Fuel=$${prices.fuel}/t (regular: $${prices.regularFuel}/t), CO2=$${prices.co2}/t (regular: $${prices.regularCO2}/t)`);
    } else {
      logger.log(`[Autopilot] Price update: Fuel=$${prices.fuel}/t, CO2=$${prices.co2}/t`);
    }

    // Also fetch and broadcast bunker state (fuel, CO2, cash levels)
    const bunker = await gameapi.fetchBunkerState();
    state.updateBunkerState(userId, bunker);

    // Broadcast prices and bunker state to all connected clients
    if (broadcastToUser) {
      // CRITICAL: Only broadcast prices if BOTH fuel AND co2 are valid (> 0)
      // DO NOT broadcast if either is 0, undefined, or null - clients will keep cached value
      if (prices.fuel > 0 &amp;&amp; prices.co2 > 0) {
        broadcastToUser(userId, 'price_update', {
          fuel: prices.fuel,
          co2: prices.co2,
          eventDiscount: prices.eventDiscount,
          regularFuel: prices.regularFuel,
          regularCO2: prices.regularCO2,
          timestamp: Date.now()
        });
        logger.log('[Autopilot]  Prices broadcasted');
      } else {
        logger.warn(`[Autopilot]  Prices NOT broadcasted - invalid values: fuel=${prices.fuel}, co2=${prices.co2}`);
      }

      broadcastToUser(userId, 'bunker_update', {
        fuel: bunker.fuel,
        co2: bunker.co2,
        cash: bunker.cash,
        maxFuel: bunker.maxFuel,
        maxCO2: bunker.maxCO2
      });
    }

    // After price update, check if alerts should be sent
    await checkPriceAlerts();

  } catch (error) {
    logger.error('[Autopilot] Failed to update prices:', error.message);
  }
}

/**
 * Checks if price alerts should be sent to users.
 * Only sends alert if price is different from last alert.
 *
 * Called after every price update (2x per hour at :01 and :31).
 */
async function checkPriceAlerts() {
  const userId = getUserId();
  if (!userId) return;

  const settings = state.getSettings(userId);
  const prices = state.getPrices(userId);

  // Skip if prices not loaded yet (both must be > 0)
  if (!prices || prices.fuel &lt;= 0 || prices.co2 &lt;= 0) {
    return;
  }

  // Check fuel alert
  if (prices.fuel &lt;= settings.fuelThreshold) {
    const lastAlert = state.getLastFuelAlert(userId);

    // Only send alert if price is different from last alert
    if (lastAlert !== prices.fuel) {
      state.setLastFuelAlert(userId, prices.fuel);

      logger.log(`[Autopilot] Fuel price alert: $${prices.fuel}/t (threshold: $${settings.fuelThreshold}/t)`);

      if (broadcastToUser) {
        broadcastToUser(userId, 'price_alert', {
          type: 'fuel',
          price: prices.fuel,
          threshold: settings.fuelThreshold
        });
      }
    }
  }

  // Check CO2 alert
  if (prices.co2 &lt;= settings.co2Threshold) {
    const lastAlert = state.getLastCO2Alert(userId);

    // Only send alert if price is different from last alert
    if (lastAlert !== prices.co2) {
      state.setLastCO2Alert(userId, prices.co2);

      logger.log(`[Autopilot] CO2 price alert: $${prices.co2}/t (threshold: $${settings.co2Threshold}/t)`);

      if (broadcastToUser) {
        broadcastToUser(userId, 'price_alert', {
          type: 'co2',
          price: prices.co2,
          threshold: settings.co2Threshold
        });
      }
    }
  }
}

// ============================================================================
// Auto-Rebuy Fuel/CO2
// ============================================================================

/**
 * Checks and executes auto-rebuy for fuel and CO2 for all active users.
 * Called by scheduler every 5 minutes AND triggered after every successful auto-depart.
 *
 * Decision Logic:
 * - NO COOLDOWNS: If conditions are met, purchases immediately
 * - Respects autopilot pause state (skips if paused)
 * - Checks individual enable flags for fuel and CO2
 * - Each resource has independent thresholds and min cash settings
 *
 * Design Philosophy:
 * - Removed artificial cooldowns to allow immediate rebuy when needed
 * - Dual trigger: timer-based (every 5 min) + event-based (after departures)
 * - This ensures bunker never runs empty during heavy departure cycles
 *
 * @async
 * @returns {Promise&lt;void>}
 */
/**
 * Auto-rebuy both fuel and CO2.
 * Convenience function that calls both autoRebuyFuel() and autoRebuyCO2().
 * Each function has its own pause/settings checks, so this just orchestrates both.
 *
 * @async
 * @returns {Promise&lt;void>}
 */
async function autoRebuyAll() {
  if (DEBUG_MODE) {
    logger.log('[Auto-Rebuy All] Checking fuel and CO2 auto-rebuy');
  }

  // OPTIMIZATION: Fetch bunker state once and pass to both functions
  // This eliminates duplicate /game/index calls (was 2, now 1)
  const bunker = await gameapi.fetchBunkerState();

  // Pass bunker state to both functions to avoid refetching
  await autoRebuyFuel(bunker);
  await autoRebuyCO2(bunker);
}

/**
 * Auto-rebuy fuel for a single user with intelligent threshold checking.
 * NO COOLDOWN - purchases whenever price is good and space available.
 *
 * Decision Logic:
 * 1. Fetches current bunker state and prices
 * 2. Checks if price &lt;= threshold (uses alert threshold or custom)
 * 3. Verifies cash balance >= minimum cash requirement
 * 4. Calculates available space and affordable amount
 * 5. Purchases fuel up to bunker capacity or cash limit
 * 6. Broadcasts purchase event and updated bunker state
 *
 * Threshold Selection:
 * - If autoRebuyFuelUseAlert=true: uses fuelThreshold (alert threshold)
 * - If autoRebuyFuelUseAlert=false: uses autoRebuyFuelThreshold (custom)
 *
 * Safety Features:
 * - Respects minimum cash balance (won't buy if cash &lt; minCash)
 * - Uses Math.ceil to always fill bunker completely
 * - Updates state immediately to prevent duplicate purchases
 *
 * API Interactions:
 * - Calls gameapi.fetchBunkerState() for current levels
 * - Calls gameapi.purchaseFuel() to execute purchase
 * - Broadcasts 'fuel_purchased' and 'bunker_update' events
 *
 * @async
 * @param {number} userId - User ID for state management
 * @returns {Promise&lt;void>}
 */
async function autoRebuyFuel(bunkerState = null) {
  // Check if autopilot is paused
  if (autopilotPaused) {
    logger.log('[Auto-Rebuy Fuel] Skipped - Autopilot is PAUSED');
    return;
  }

  const userId = getUserId();
  if (!userId) return;

  // Check settings
  const settings = state.getSettings(userId);
  if (!settings.autoRebuyFuel) {
    if (DEBUG_MODE) {
      logger.log('[Auto-Rebuy Fuel] Feature disabled in settings');
    }
    return;
  }

  try {
    // Get current state (use provided state or fetch fresh)
    const bunker = bunkerState || await gameapi.fetchBunkerState();
    state.updateBunkerState(userId, bunker);

    // Broadcast bunker state to all clients
    if (broadcastToUser) {
      broadcastToUser(userId, 'bunker_update', {
        fuel: bunker.fuel,
        co2: bunker.co2,
        cash: bunker.cash,
        maxFuel: bunker.maxFuel,
        maxCO2: bunker.maxCO2
      });
    }

    const prices = state.getPrices(userId);

    logger.debug(`[Auto-Rebuy Fuel] Check: Enabled=${settings.autoRebuyFuel}, Price=${prices.fuel}, Bunker=${bunker.fuel.toFixed(1)}/${bunker.maxFuel}t`);

    // Check if prices have been fetched yet
    if (!prices.fuel || prices.fuel === 0) {
      logger.debug('[Auto-Rebuy Fuel] No price data available yet');
      return;
    }

    // Determine threshold (use custom or alert threshold)
    const threshold = settings.autoRebuyFuelUseAlert
      ? settings.fuelThreshold
      : settings.autoRebuyFuelThreshold;

    logger.debug(`[Auto-Rebuy Fuel] Threshold check: Price $${prices.fuel}/t vs Threshold $${threshold}/t (UseAlert=${settings.autoRebuyFuelUseAlert})`);

    // Check if price is at or below threshold
    if (prices.fuel > threshold) {
      logger.debug(`[Auto-Rebuy Fuel] Price too high: $${prices.fuel}/t > $${threshold}/t threshold`);
      return;
    }

    // Check if bunker has space
    const availableSpace = bunker.maxFuel - bunker.fuel;
    if (availableSpace &lt; 0.5) {
      if (DEBUG_MODE) {
        logger.log('[Auto-Rebuy Fuel] Bunker full');
      }
      return; // Bunker full
    }

    // Fill to max capacity - use Math.ceil to always buy enough to fill completely
    const amountNeeded = Math.ceil(availableSpace);

    // Calculate how much we can buy while keeping minCash reserve
    const minCash = settings.autoRebuyFuelMinCash;
    if (minCash === undefined || minCash === null) {
      logger.error('[Auto-Rebuy Fuel] ERROR: autoRebuyFuelMinCash setting is missing!');
      return;
    }
    const cashAvailable = Math.max(0, bunker.cash - minCash);
    const maxAffordable = Math.floor(cashAvailable / prices.fuel);

    // Buy as much as we can (limited by space or money)
    const amountToBuy = Math.min(amountNeeded, maxAffordable);

    logger.debug(`[Auto-Rebuy Fuel] Calculations: Space=${availableSpace.toFixed(1)}t, Cash=$${bunker.cash.toLocaleString()}, MinCash=$${minCash.toLocaleString()}, Available=$${cashAvailable.toLocaleString()}, MaxAffordable=${maxAffordable}t, ToBuy=${amountToBuy}t`);

    if (amountToBuy &lt;= 0) {
      logger.log(`[Auto-Rebuy Fuel] Cannot buy: Not enough cash after keeping minimum reserve`);
      return;
    }

    const totalCost = amountToBuy * prices.fuel;
    const cashAfterPurchase = bunker.cash - totalCost;
    logger.debug(`[Auto-Rebuy Fuel] Purchasing ${amountToBuy}t @ $${prices.fuel}/t = $${totalCost.toLocaleString()} (Cash after: $${cashAfterPurchase.toLocaleString()})`);
    logger.debug(`[Auto-Rebuy Fuel] Current bunker state BEFORE purchase: Cash=$${bunker.cash.toLocaleString()}, Fuel=${bunker.fuel.toFixed(1)}t/${bunker.maxFuel}t`);

    // Purchase fuel - pass the price so cost can be calculated
    const result = await gameapi.purchaseFuel(amountToBuy, prices.fuel);

    logger.debug(`[Auto-Rebuy Fuel] Purchase successful, API returned: newTotal=${result.newTotal.toFixed(1)}t, cost=$${result.cost.toLocaleString()}`);

    // Update bunker state
    bunker.fuel = result.newTotal;
    bunker.cash -= result.cost;
    state.updateBunkerState(userId, bunker);

    // Broadcast success
    if (broadcastToUser) {
      if (DEBUG_MODE) {
        logger.log(`[Auto-Rebuy Fuel] Broadcasting fuel_purchased event (Desktop notifications: ${settings.enableDesktopNotifications ? 'ENABLED' : 'DISABLED'})`);
      }
      broadcastToUser(userId, 'fuel_purchased', {
        amount: amountToBuy,
        price: prices.fuel,
        newTotal: result.newTotal,
        cost: result.cost
      });

      // Broadcast updated bunker state (fuel AND cash changed)
      broadcastToUser(userId, 'bunker_update', {
        fuel: bunker.fuel,
        co2: bunker.co2,
        cash: bunker.cash,
        maxFuel: bunker.maxFuel,
        maxCO2: bunker.maxCO2
      });
    }

    logger.log(`[Auto-Rebuy Fuel] Purchased ${amountToBuy}t @ $${prices.fuel}/t (New total: ${result.newTotal.toFixed(1)}t)`);

  } catch (error) {
    logger.error('[Auto-Rebuy Fuel] Error:', error.message);
  }
}

/**
 * Auto-rebuy CO2 for a single user with intelligent threshold checking.
 * NO COOLDOWN - purchases whenever price is good and space available.
 *
 * Decision Logic:
 * 1. Fetches current bunker state and prices
 * 2. Checks if price &lt;= threshold (uses alert threshold or custom)
 * 3. Verifies cash balance >= minimum cash requirement
 * 4. Calculates available space and affordable amount
 * 5. Purchases CO2 up to bunker capacity or cash limit
 * 6. Broadcasts purchase event and updated bunker state
 *
 * Threshold Selection:
 * - If autoRebuyCO2UseAlert=true: uses co2Threshold (alert threshold)
 * - If autoRebuyCO2UseAlert=false: uses autoRebuyCO2Threshold (custom)
 *
 * Safety Features:
 * - Respects minimum cash balance (won't buy if cash &lt; minCash)
 * - Uses Math.ceil to always fill bunker completely
 * - Updates state immediately to prevent duplicate purchases
 *
 * API Interactions:
 * - Calls gameapi.fetchBunkerState() for current levels
 * - Calls gameapi.purchaseCO2() to execute purchase
 * - Broadcasts 'co2_purchased' and 'bunker_update' events
 *
 * @async
 * @param {number} userId - User ID for state management
 * @returns {Promise&lt;void>}
 */
async function autoRebuyCO2(bunkerState = null) {
  // Check if autopilot is paused
  if (autopilotPaused) {
    logger.log('[Auto-Rebuy CO2] Skipped - Autopilot is PAUSED');
    return;
  }

  const userId = getUserId();
  if (!userId) return;

  // Check settings
  const settings = state.getSettings(userId);
  if (!settings.autoRebuyCO2) {
    if (DEBUG_MODE) {
      logger.log('[Auto-Rebuy CO2] Feature disabled in settings');
    }
    return;
  }

  try {
    // Get current state (use provided state or fetch fresh)
    const bunker = bunkerState || await gameapi.fetchBunkerState();
    state.updateBunkerState(userId, bunker);

    // Broadcast bunker state to all clients
    if (broadcastToUser) {
      broadcastToUser(userId, 'bunker_update', {
        fuel: bunker.fuel,
        co2: bunker.co2,
        cash: bunker.cash,
        maxFuel: bunker.maxFuel,
        maxCO2: bunker.maxCO2
      });
    }

    const prices = state.getPrices(userId);

    logger.debug(`[Auto-Rebuy CO2] Check: Enabled=${settings.autoRebuyCO2}, Price=${prices.co2}, Bunker=${bunker.co2.toFixed(1)}/${bunker.maxCO2}t`);

    // Check if prices have been fetched yet
    if (!prices.co2 || prices.co2 === 0) {
      logger.debug('[Auto-Rebuy CO2] No price data available yet');
      return;
    }

    // Determine threshold (use custom or alert threshold)
    const threshold = settings.autoRebuyCO2UseAlert
      ? settings.co2Threshold
      : settings.autoRebuyCO2Threshold;

    logger.debug(`[Auto-Rebuy CO2] Threshold check: Price $${prices.co2}/t vs Threshold $${threshold}/t (UseAlert=${settings.autoRebuyCO2UseAlert})`);

    // Check if price is at or below threshold
    if (prices.co2 > threshold) {
      logger.debug(`[Auto-Rebuy CO2] Price too high: $${prices.co2}/t > $${threshold}/t threshold`);
      return;
    }

    // Check if bunker has space
    const availableSpace = bunker.maxCO2 - bunker.co2;
    if (availableSpace &lt; 0.5) {
      if (DEBUG_MODE) {
        logger.log('[Auto-Rebuy CO2] Bunker full');
      }
      return; // Bunker full
    }

    // Fill to max capacity - use Math.ceil to always buy enough to fill completely
    const amountNeeded = Math.ceil(availableSpace);

    // Calculate how much we can buy while keeping minCash reserve
    const minCash = settings.autoRebuyCO2MinCash;
    if (minCash === undefined || minCash === null) {
      logger.error('[Auto-Rebuy CO2] ERROR: autoRebuyCO2MinCash setting is missing!');
      return;
    }
    const cashAvailable = Math.max(0, bunker.cash - minCash);
    const maxAffordable = Math.floor(cashAvailable / prices.co2);

    // Buy as much as we can (limited by space or money)
    const amountToBuy = Math.min(amountNeeded, maxAffordable);

    logger.debug(`[Auto-Rebuy CO2] Calculations: Space=${availableSpace.toFixed(1)}t, Cash=$${bunker.cash.toLocaleString()}, MinCash=$${minCash.toLocaleString()}, Available=$${cashAvailable.toLocaleString()}, MaxAffordable=${maxAffordable}t, ToBuy=${amountToBuy}t`);

    if (amountToBuy &lt;= 0) {
      logger.log(`[Auto-Rebuy CO2] Cannot buy: Not enough cash after keeping minimum reserve`);
      return;
    }

    const totalCost = amountToBuy * prices.co2;
    const cashAfterPurchase = bunker.cash - totalCost;
    logger.debug(`[Auto-Rebuy CO2] Purchasing ${amountToBuy}t @ $${prices.co2}/t = $${totalCost.toLocaleString()} (Cash after: $${cashAfterPurchase.toLocaleString()})`);

    // Purchase CO2 - pass the price so cost can be calculated
    const result = await gameapi.purchaseCO2(amountToBuy, prices.co2);

    // Update bunker state
    bunker.co2 = result.newTotal;
    bunker.cash -= result.cost;
    state.updateBunkerState(userId, bunker);

    // Broadcast success
    if (broadcastToUser) {
      if (DEBUG_MODE) {
        logger.log(`[Auto-Rebuy CO2] Broadcasting co2_purchased event (Desktop notifications: ${settings.enableDesktopNotifications ? 'ENABLED' : 'DISABLED'})`);
      }
      broadcastToUser(userId, 'co2_purchased', {
        amount: amountToBuy,
        price: prices.co2,
        newTotal: result.newTotal,
        cost: result.cost
      });

      // Broadcast updated bunker state (CO2 AND cash changed)
      broadcastToUser(userId, 'bunker_update', {
        fuel: bunker.fuel,
        co2: bunker.co2,
        cash: bunker.cash,
        maxFuel: bunker.maxFuel,
        maxCO2: bunker.maxCO2
      });
    }

    logger.log(`[Auto-Rebuy CO2] Purchased ${amountToBuy}t @ $${prices.co2}/t (New total: ${result.newTotal.toFixed(1)}t)`);

  } catch (error) {
    logger.error('[Auto-Rebuy CO2] Error:', error.message);
  }
}

// ============================================================================
// Auto-Depart Vessels
// ============================================================================

/**
 * Universal vessel departure function with intelligent demand-based routing.
 * Works with any list of vessel IDs or all vessels if vesselIds=null.
 * Used by BOTH autopilot and manual departure operations.
 *
 * Core Algorithm:
 * 1. Fetch current bunker state and check minimum fuel threshold
 * 2. Fetch ALL vessels and filter by status='port' and not parked
 * 3. If vesselIds provided, filter to only those IDs
 * 4. Group vessels by destination+type for efficient processing
 * 5. For each group, sort by capacity (largest first)
 * 6. For EACH vessel individually:
 *    a. Fetch FRESH port data to avoid race conditions
 *    b. Calculate remaining demand at destination
 *    c. Fetch FRESH vessel list to get current en-route capacity
 *    d. Calculate effective demand (remaining - en-route)
 *    e. Check price-per-TEU using auto-price API (CRITICAL $0 check)
 *    f. Verify minimum utilization threshold
 *    g. Depart vessel if all checks pass
 *    h. Track success/failure with detailed reasons
 * 7. Send batch notifications every 20 vessels
 * 8. Trigger auto-rebuy after each successful batch
 * 9. Update bunker state after all departures
 *
 * Race Condition Prevention:
 * - Fetches FRESH port data BEFORE EACH departure (not once at start)
 * - Fetches FRESH vessel list to calculate actual en-route capacity
 * - This prevents $0 revenue when vessels arrive during the loop
 * - Handles "vessel already departed" errors gracefully (skip, don't fail)
 *
 * Critical $0 Revenue Protection:
 * - Calls fetchAutoPrice() for EVERY vessel BEFORE departure
 * - Blocks departure if price-per-TEU is $0 at destination
 * - This happens when port has NO cargo price configured
 * - If API fails, BLOCKS departure to prevent potential losses
 * - Rationale: Better to skip a trip than waste fuel/CO2/harbor fees for $0
 *
 * CO2 Quirk Handling:
 * - Game API returns "error" for low CO2 but STILL sends vessel
 * - We detect CO2 errors and skip notification (vessel already en-route)
 * - No stats available for these vessels (API doesn't return them)
 * - CO2 can go negative in game (it's not a real blocker)
 *
 * Negative Income Detection:
 * - If vessel departs with negative net income (harbor fee > revenue)
 * - Logs critical error and adds to FAILED vessels (not success)
 * - This happens due to race conditions despite demand checks
 * - Indicates low cargo loaded (utilization check may have race condition)
 *
 * Batch Processing:
 * - Processes vessels in chunks of 20 (CHUNK_SIZE constant)
 * - Sends combined notification after each chunk
 * - Triggers auto-rebuy after successful batches
 * - Prevents overwhelming frontend with hundreds of individual notifications
 *
 * Vessel Filtering:
 * - Skips vessels with no route assigned
 * - Skips vessels with active delivery contracts (delivery_price > 0)
 * - Skips parked vessels (is_parked = true)
 * - Only processes vessels with status='port'
 *
 * Speed &amp; Guards:
 * - If autoDepartUseRouteDefaults=true: uses vessel's saved route_speed/route_guards
 * - If autoDepartUseRouteDefaults=false: uses autoVesselSpeed setting (% of max_speed)
 * - Guards always use route_guards (no separate setting)
 *
 * Utilization Checking:
 * - Calculates cargo to load: min(effectiveDemand, vesselCapacity)
 * - Utilization rate = cargoToLoad / vesselCapacity
 * - Skips if utilization &lt; minVesselUtilization setting
 * - This prevents sending large vessels for small cargo (unprofitable)
 *
 * API Interactions:
 * - gameapi.fetchBunkerState() - Check fuel levels
 * - gameapi.fetchVessels() - Get vessel list (called multiple times for fresh data)
 * - gameapi.fetchAssignedPorts() - Get port demand (called BEFORE EACH depart)
 * - gameapi.fetchAutoPrice(vesselId, routeId) - Check destination prices
 * - gameapi.departVessel(vesselId, speed, guards) - Execute departure
 *
 * Broadcasting Events:
 * - 'vessel_count_update' - Initial count of vessels in each status
 * - 'vessels_depart_complete' - Batch completion with succeeded/failed vessels
 * - 'bunker_update' - Updated fuel/CO2/cash after departures
 * - 'notification' - Error notifications (e.g., insufficient fuel)
 *
 * @async
 * @param {number} userId - User ID for state management
 * @param {Array&lt;number>|null} vesselIds - Array of vessel IDs to depart, or null for all vessels
 * @returns {Promise&lt;Object>} Result object: { success: boolean, reason?: string, error?: string }
 */
async function departVessels(userId, vesselIds = null) {
  try {
    const settings = state.getSettings(userId);

    // Get current bunker state
    const bunker = await gameapi.fetchBunkerState();
    state.updateBunkerState(userId, bunker);

    // Check if fuel is too low (use minFuelThreshold setting)
    if (bunker.fuel &lt; settings.minFuelThreshold) {
      logger.log(`[Depart] Skipping - insufficient fuel (${bunker.fuel.toFixed(1)}t &lt; ${settings.minFuelThreshold}t minimum)`);

      // Notify user about insufficient fuel
      if (broadcastToUser) {
        broadcastToUser(userId, 'notification', {
          type: 'error',
          message: `&lt;p>&lt;strong>Harbor master&lt;/strong>&lt;/p>&lt;p>Cannot depart vessels - insufficient fuel!&lt;br>Current: ${bunker.fuel.toFixed(1)}t | Required minimum: ${settings.minFuelThreshold}t&lt;/p>`
        });
      }
      return { success: false, reason: 'insufficient_fuel' };
    }

    // Fetch vessels ONCE at the start
    const allVessels = await gameapi.fetchVessels();
    // NOTE: We will fetch port data BEFORE EACH DEPART to avoid race conditions

    // Filter vessels: either specific IDs or all in harbor
    let harbourVessels;
    if (vesselIds &amp;&amp; vesselIds.length > 0) {
      // Filter by specific vessel IDs
      const vesselIdSet = new Set(vesselIds);
      harbourVessels = allVessels.filter(v =>
        vesselIdSet.has(v.id) &amp;&amp;
        v.status === 'port' &amp;&amp;
        !v.is_parked
      );
      if (DEBUG_MODE) {
        logger.log(`[Depart] Filtering ${vesselIds.length} requested vessels, found ${harbourVessels.length} in harbor`);
      }
    } else {
      // Depart ALL vessels in harbor
      harbourVessels = allVessels.filter(v => v.status === 'port' &amp;&amp; !v.is_parked);
    }

    if (DEBUG_MODE) {
      logger.log(`[Depart] Found ${harbourVessels.length} vessels to process (total: ${allVessels.length})`);
    }

    // Broadcast vessel count to all clients (use consistent format)
    if (broadcastToUser) {
      const readyToDepart = allVessels.filter(v => v.status === 'port').length;
      const atAnchor = allVessels.filter(v => v.status === 'anchor').length;
      const pending = allVessels.filter(v => v.status === 'pending').length;

      broadcastToUser(userId, 'vessel_count_update', {
        readyToDepart,
        atAnchor,
        pending
      });
    }

    if (harbourVessels.length === 0) {
      if (DEBUG_MODE) {
        logger.log('[Depart] No vessels to depart, skipping');
      }
      return { success: true, reason: 'no_vessels' };
    }

    // Notify frontend that autopilot departure has started (locks depart button)
    if (broadcastToUser) {
      broadcastToUser(userId, 'autopilot_depart_start', {
        vesselCount: harbourVessels.length
      });
    }

    // Track departed and failed vessels
    const departedVessels = [];
    const failedVessels = [];
    const CHUNK_SIZE = 20;
    let processedCount = 0;

    // Helper function to send notifications for current batch
    async function sendBatchNotifications() {
      // Send combined notification if there are any vessels (departed or failed)
      if (departedVessels.length > 0 || failedVessels.length > 0) {
        const totalIncome = departedVessels.reduce((sum, v) => sum + v.income, 0);
        const totalHarborFee = departedVessels.reduce((sum, v) => sum + v.harborFee, 0);
        const totalNetIncome = departedVessels.reduce((sum, v) => sum + v.netIncome, 0);
        const totalFuelUsed = departedVessels.reduce((sum, v) => sum + v.fuelUsed, 0);
        const totalCO2Used = departedVessels.reduce((sum, v) => sum + v.co2Used, 0);

        if (DEBUG_MODE) {
          logger.log(`[Depart] Batch: ${departedVessels.length} departed, ${failedVessels.length} failed - Net: $${totalNetIncome.toLocaleString()}`);
        }

        if (broadcastToUser) {
          const bunkerState = await gameapi.fetchBunkerState();

          // Send combined event with both succeeded and failed vessels
          broadcastToUser(userId, 'vessels_depart_complete', {
            succeeded: {
              count: departedVessels.length,
              vessels: departedVessels.slice(),
              totalIncome: totalIncome,
              totalHarborFee: totalHarborFee,
              totalNetIncome: totalNetIncome,
              totalFuelUsed: totalFuelUsed,
              totalCO2Used: totalCO2Used
            },
            failed: {
              count: failedVessels.length,
              vessels: failedVessels.slice()
            },
            bunker: {
              fuel: bunkerState.fuel,
              co2: bunkerState.co2
            }
          });
        }

        // Trigger auto-rebuy after each successful batch (if enabled)
        if (departedVessels.length > 0) {
          if (DEBUG_MODE) {
            logger.log(`[Depart] Triggering auto-rebuy after ${departedVessels.length} vessels departed in this batch`);
          }
          await autoRebuyAll();
        }

        departedVessels.length = 0; // Clear array for next batch
        failedVessels.length = 0; // Clear array for next batch
      }
    }

    // Group vessels by destination and type
    const vesselsByDestinationAndType = {};

    for (const vessel of harbourVessels) {
      if (!vessel.route_destination) {
        if (DEBUG_MODE) {
          logger.log(`[Depart] Skipping ${vessel.name}: no route destination`);
        }
        failedVessels.push({
          name: vessel.name,
          destination: 'Unknown',
          reason: 'No route assigned'
        });
        continue;
      }
      if (vessel.delivery_price !== null &amp;&amp; vessel.delivery_price > 0) {
        if (DEBUG_MODE) {
          logger.log(`[Depart] Skipping ${vessel.name}: delivery contract active ($${vessel.delivery_price})`);
        }
        failedVessels.push({
          name: vessel.name,
          destination: vessel.route_destination || 'Unknown',
          reason: 'Delivery contract active'
        });
        continue;
      }

      const destination = vessel.route_destination;
      const type = vessel.capacity_type;
      const key = `${destination}_${type}`;

      if (!vesselsByDestinationAndType[key]) {
        vesselsByDestinationAndType[key] = [];
      }
      vesselsByDestinationAndType[key].push(vessel);
    }

    if (DEBUG_MODE) {
      logger.log(`[Depart] Grouped vessels into ${Object.keys(vesselsByDestinationAndType).length} destination+type groups`);
    }

    // Process each destination+type group
    for (const key in vesselsByDestinationAndType) {
      const vessels = vesselsByDestinationAndType[key];
      const firstVessel = vessels[0];
      const vesselType = firstVessel.capacity_type;

      if (DEBUG_MODE) {
        logger.log(`[Depart] Processing group: ${key} (${vessels.length} vessels)`);
      }

      // Determine next destination
      let destination;
      if (firstVessel.route_destination === firstVessel.current_port_code) {
        destination = firstVessel.route_origin;
      } else if (firstVessel.route_origin === firstVessel.current_port_code) {
        destination = firstVessel.route_destination;
      } else {
        destination = firstVessel.route_destination;
      }

      if (DEBUG_MODE) {
        logger.log(`[Depart] Destination: ${destination}`);
      }

      // Sort vessels by capacity (largest first)
      const sortedVessels = vessels.sort((a, b) => getTotalCapacity(b) - getTotalCapacity(a));

      // Process each vessel individually with FRESH port data
      for (const vessel of sortedVessels) {
        const vesselCapacity = getTotalCapacity(vessel);

        // CRITICAL: Fetch FRESH port data BEFORE EACH depart to avoid race conditions
        // This prevents $0 revenue when vessels arrive at destination during the depart loop
        const freshPorts = await gameapi.fetchAssignedPorts();
        const port = freshPorts.find(p => p.code === destination);

        if (!port) {
          failedVessels.push({
            name: vessel.name,
            destination: destination,
            reason: 'Port not in assigned ports'
          });
          continue;
        }

        // Calculate CURRENT remaining demand with fresh data
        const remainingDemand = calculateRemainingDemand(port, vesselType);

        // SIMPLIFIED DEMAND CHECK:
        // Demand is reduced as soon as a ship departs (by the game API).
        // We don't need to calculate vessels en-route - just check if demand > 0.
        // If demand exists when we depart, we get paid. If not, we don't.

        /* OLD COMPLEX LOGIC (commented out):
        // Find vessels CURRENTLY en-route (some may have arrived since we started)
        const currentVessels = await gameapi.fetchVessels();
        const vesselsEnroute = currentVessels.filter(v =>
          v.status === 'enroute' &amp;&amp;
          v.route_destination === destination &amp;&amp;
          v.capacity_type === vesselType
        );

        // Calculate capacity en-route
        const capacityEnroute = vesselsEnroute.reduce((sum, v) => sum + getTotalCapacity(v), 0);

        // Effective demand with FRESH data
        const effectiveDemand = Math.max(0, remainingDemand - capacityEnroute);

        if (DEBUG_MODE) {
          logger.log(`[Depart] ${vessel.name}: Fresh demand check - Remaining: ${remainingDemand}, En-route: ${capacityEnroute}, Effective: ${effectiveDemand}`);
        }
        */

        if (DEBUG_MODE) {
          logger.log(`[Depart] ${vessel.name}: Demand check - Remaining: ${remainingDemand}`);
        }

        // Skip if no demand
        if (remainingDemand &lt;= 0) {
          failedVessels.push({
            name: vessel.name,
            destination: destination,
            reason: `No demand at destination`
          });
          continue;
        }

        // CRITICAL: Check if price-per-TEU is 0 at destination using auto-price API
        // This happens when the destination port has NO cargo price configured
        // Sending vessels would result in $0 revenue and wasted fuel/CO2
        try {
          if (vessel.route_id) {
            const autoPriceData = await gameapi.fetchAutoPrice(vessel.id, vessel.route_id);

            // Check if the auto-price returns 0 or null for prices
            // API returns: dry, ref, fuel, crude_oil (not price_dry, etc.)
            const dryPrice = autoPriceData?.data?.dry || 0;
            const refPrice = autoPriceData?.data?.ref || 0;
            const fuelPrice = autoPriceData?.data?.fuel || 0;
            const crudePrice = autoPriceData?.data?.crude_oil || 0;

            // For container vessels, check dry and ref prices
            // For tankers, check fuel and crude prices
            const hasValidPrice = vesselType === 'container'
              ? (dryPrice > 0 || refPrice > 0)
              : (fuelPrice > 0 || crudePrice > 0);

            if (!hasValidPrice) {
              logger.log(`[Depart]  ${vessel.name}: Price per TEU is $0 at ${destination} - BLOCKING departure to avoid losses`);
              failedVessels.push({
                name: vessel.name,
                destination: destination,
                reason: `CRITICAL: Price per TEU is $0 at destination - would result in losses`
              });
              continue;
            }

            if (DEBUG_MODE) {
              logger.log(`[Depart] ${vessel.name}: Price check OK - Dry: $${dryPrice}, Ref: $${refPrice}, Fuel: $${fuelPrice}, Crude: $${crudePrice}`);
            }
          }
        } catch (error) {
          // CRITICAL: If auto-price API fails, we MUST block departure!
          // We cannot risk sending vessels without knowing if destination price is $0
          // This would waste fuel, CO2, and harbor fees for zero or negative income
          logger.error(`[Depart] ${vessel.name}: Failed to fetch auto-price - BLOCKING departure to avoid potential losses`);
          logger.error(`[Depart] Error details: ${error.message}`);
          failedVessels.push({
            name: vessel.name,
            destination: destination,
            reason: `Cannot verify destination price (API error: ${error.message}) - blocking to prevent potential losses`
          });
          continue;
        }

        // Check utilization (use full remaining demand, not effective)
        const cargoToLoad = Math.min(remainingDemand, vesselCapacity);
        const utilizationRate = vesselCapacity > 0 ? cargoToLoad / vesselCapacity : 0;
        const minUtilization = settings.minVesselUtilization / 100;

        if (utilizationRate &lt; minUtilization) {
          failedVessels.push({
            name: vessel.name,
            destination: destination,
            reason: `Utilization too low (${(utilizationRate * 100).toFixed(0)}% &lt; ${(minUtilization * 100).toFixed(0)}%)`
          });
          continue;
        }

        // Determine speed and guards
        let speed, guards;

        if (settings.autoDepartUseRouteDefaults) {
          speed = vessel.route_speed || vessel.max_speed;
          guards = vessel.route_guards || 0;
        } else {
          const speedPercent = settings.autoVesselSpeed;
          speed = Math.round(vessel.max_speed * (speedPercent / 100));
          guards = vessel.route_guards || 0;
        }

        try {
          if (DEBUG_MODE) {
            logger.log(`[Depart] Attempting to depart vessel: name="${vessel.name}", id=${vessel.id}, status="${vessel.status}"`);
          }
          const result = await gameapi.departVessel(vessel.id, speed, guards);

          // Check if departure failed
          if (result.success === false) {
            // SPECIAL CASE: Vessel already departed (race condition from batch processing)
            if (result.error === 'Vessel not found or status invalid') {
              logger.log(`[Depart] Vessel ${vessel.name} was already departed (race condition - ignoring)`);
              // Skip this vessel completely - it's already gone
              continue;
            }

            // SPECIAL CASE: CO2 "errors" are not real errors - CO2 can go negative
            // The game API returns an error but still sends the vessel
            // However, we don't get the actual income/fuel values back, so we SKIP showing it
            if (result.errorMessage &amp;&amp; (result.errorMessage.toLowerCase().includes('co2') ||
                                       result.errorMessage.toLowerCase().includes('emission'))) {
              logger.log(`[Depart] ${vessel.name} departed with CO2 warning - vessel sent but no stats available, skipping notification`);
              // DO NOT add to departedVessels - we don't have real values
              // DO NOT add to failedVessels - vessel was actually sent
              // Just continue silently (demand will be recalculated fresh for next vessel)
              continue;
            }

            logger.log(`[Depart] Failed to depart ${vessel.name}: "${result.errorMessage}"`);

            // Try to extract more detailed error information
            let detailedReason = result.errorMessage;
            if (result.apiResponse &amp;&amp; result.apiResponse.message) {
              detailedReason = result.apiResponse.message;
            }

            // Check for specific error types
            const lowerReason = detailedReason.toLowerCase();

            // Fuel shortage - show only required amount (available is in bunker box above)
            if (lowerReason.includes('fuel') || lowerReason.includes('bunker')) {
              // Try to get required fuel from vessel route data
              const requiredFuel = vessel.route_fuel_required || vessel.fuel_required;
              if (requiredFuel) {
                detailedReason = `No fuel (${requiredFuel.toFixed(1)}t)`;
              } else {
                detailedReason = 'No fuel';
              }
            }
            // Demand shortage
            else if (lowerReason.includes('demand') || (remainingDemand &lt;= 0 &amp;&amp; lowerReason.includes('failed'))) {
              detailedReason = `No demand at ${destination} (${remainingDemand.toFixed(1)}t remaining demand, vessel capacity ${vesselCapacity.toFixed(1)}t)`;
            }
            // Generic "failed to depart" - just use the original message
            // We don't actually know why it failed, so don't guess
            else if (lowerReason === 'failed to depart vessel') {
              detailedReason = result.errorMessage || 'Failed to depart vessel';
            }

            failedVessels.push({
              name: vessel.name,
              destination: destination,
              reason: detailedReason
            });
            continue;
          }

          // Check if departure was successful but silent failure (shouldn't happen with new error handling)
          if (result.income === 0 &amp;&amp; result.fuelUsed === 0) {
            continue; // Failed silently (insufficient fuel) - CO2 never blocks departure
          }

          // Check for $0 revenue or NEGATIVE net income departures
          // This happens when vessel departed but demand was exhausted between check and depart
          // The vessel is already en-route (can't be stopped), but we should warn the user
          if (result.income === 0 &amp;&amp; result.harborFee === 0) {
            logger.log(`[Depart] WARNING: ${vessel.name} departed with $0 revenue - demand exhausted during batch, skipping statistics`);
            // Don't add to departedVessels OR failedVessels - just ignore it
            // The vessel is en-route but we won't count it in statistics
            continue;
          }

          // Check if vessel departed with NEGATIVE net income (known game bug)
          // This is a known bug in the game API - harbor fee calculation is incorrect
          // The vessel WAS successfully sent, so we count it as success (not failure)
          const hasFeeCalculationBug = result.netIncome &lt; 0;

          // Successfully departed (even if fee calculation is buggy)
          departedVessels.push({
            name: result.vesselName,
            destination: result.destination,
            capacity: vesselCapacity,
            utilization: utilizationRate,
            cargoLoaded: cargoToLoad,
            speed: result.speed,
            guards: result.guards,
            income: result.income,
            harborFee: result.harborFee,
            netIncome: result.netIncome,
            hasFeeCalculationBug: hasFeeCalculationBug,  // Mark for UI display
            fuelUsed: result.fuelUsed,
            co2Used: result.co2Used
          });

          // Note: effectiveDemand will be recalculated fresh for next vessel

        } catch (error) {
          logger.error(`[Depart] Failed to depart ${vessel.name}:`, error.message);
          failedVessels.push({
            name: vessel.name,
            destination: destination,
            reason: error.message || 'Unknown error'
          });
        }

        // Check if we've processed a chunk of vessels
        processedCount++;
        if (processedCount % CHUNK_SIZE === 0) {
          await sendBatchNotifications();
        }
      }
    }

    // Send final batch for any remaining vessels (less than CHUNK_SIZE)
    if (departedVessels.length > 0 || failedVessels.length > 0) {
      await sendBatchNotifications();
    }

    // Trigger rebuy and update data after departures
    if (processedCount > 0) {
      // Auto-rebuy after vessels departed
      await autoRebuyAll();

      // Update all data (SKIP if locked)
      await tryUpdateAllData();
    }

    return { success: true };

  } catch (error) {
    logger.error('[Depart] Error:', error.message);
    return { success: false, reason: 'error', error: error.message };
  }
}

/**
 * Intelligent auto-depart wrapper for autopilot system.
 * Calls departVessels() with null vesselIds to depart ALL vessels in harbor.
 *
 * Why This Exists:
 * - Separates autopilot-specific logic from universal depart function
 * - Checks autoDepartAll setting before calling universal function
 * - Provides consistent entry point for autopilot scheduler
 * - Allows different triggering logic for manual vs automatic departures
 *
 * @async
 * @returns {Promise&lt;void>}
 */
async function autoDepartVessels() {
  // Check if autopilot is paused
  if (autopilotPaused) {
    logger.log('[Auto-Depart] Skipped - Autopilot is PAUSED');
    return;
  }

  const userId = getUserId();
  if (!userId) return;

  const settings = state.getSettings(userId);

  if (!settings.autoDepartAll) {
    if (DEBUG_MODE) {
      logger.log('[Auto-Depart] Feature disabled in settings');
    }
    return;
  }

  if (DEBUG_MODE) {
    logger.log(`[Auto-Depart] Checking... ${settings.autoDepartAll ? 'ENABLED' : 'DISABLED'}`);
  }

  // Call universal depart function with all vessels (vesselIds = null)
  await departVessels(userId, null);
}

/**
 * Calculates remaining demand at a port.
 *
 * @param {Object} port - Port object
 * @param {string} vesselType - 'container' or 'tanker'
 * @returns {number} Remaining demand
 */
function calculateRemainingDemand(port, vesselType) {
  if (vesselType === 'container') {
    const dryDemand = port.demand?.container?.dry || 0;
    const dryConsumed = port.consumed?.container?.dry || 0;
    const refDemand = port.demand?.container?.refrigerated || 0;
    const refConsumed = port.consumed?.container?.refrigerated || 0;

    return (dryDemand - dryConsumed) + (refDemand - refConsumed);
  } else if (vesselType === 'tanker') {
    const fuelDemand = port.demand?.tanker?.fuel || 0;
    const fuelConsumed = port.consumed?.tanker?.fuel || 0;
    const crudeDemand = port.demand?.tanker?.crude_oil || 0;
    const crudeConsumed = port.consumed?.tanker?.crude_oil || 0;

    return (fuelDemand - fuelConsumed) + (crudeDemand - crudeConsumed);
  }

  return 0;
}

/**
 * Calculates total capacity of a vessel.
 *
 * @param {Object} vessel - Vessel object
 * @returns {number} Total capacity
 */
function getTotalCapacity(vessel) {
  if (vessel.capacity_type === 'container') {
    return (vessel.capacity_max?.dry || 0) + (vessel.capacity_max?.refrigerated || 0);
  } else if (vessel.capacity_type === 'tanker') {
    return (vessel.capacity_max?.fuel || 0) + (vessel.capacity_max?.crude_oil || 0);
  }
  return 0;
}

// ============================================================================
// Auto Bulk Repair
// ============================================================================


/**
 * Auto repair vessels for a single user based on wear threshold.
 *
 * Decision Logic:
 * 1. Fetches all vessels and filters by wear >= maintenanceThreshold
 * 2. Checks minimum cash balance requirement
 * 3. Fetches repair cost for all vessels needing repair
 * 4. If affordable, repairs all vessels in bulk
 * 5. Broadcasts repair notification with vessel list and costs
 *
 * API Quirk - $0 Cost Bug:
 * - Sometimes API returns totalCost=$0 even when repair is valid
 * - We attempt repair anyway as workaround for this API bug
 * - Actual cost is deducted from cash regardless of API response
 *
 * Cost Calculation:
 * - Calls gameapi.getMaintenanceCost(vesselIds) for total cost
 * - Individual vessel costs extracted from maintenance_data array
 * - Cost depends on wear level and vessel value
 *
 * Safety Features:
 * - Respects minimum cash balance (won't repair if cash &lt; minCash)
 * - Bulk repairs all vessels in single API call (efficient)
 * - Includes detailed vessel list in notification (name, wear, cost)
 *
 * API Interactions:
 * - gameapi.fetchBunkerState() - Check cash balance
 * - gameapi.fetchVessels() - Get vessels with wear data
 * - gameapi.getMaintenanceCost(vesselIds) - Calculate repair cost
 * - gameapi.bulkRepairVessels(vesselIds) - Execute repairs
 *
 * Broadcasting:
 * - 'vessels_repaired' - Notification with count, cost, vessel details
 *
 * @async
 * @param {number} userId - User ID for state and settings
 * @returns {Promise&lt;void>}
 */
async function autoRepairVessels() {
  // Check if autopilot is paused
  if (autopilotPaused) {
    logger.log('[Auto-Repair] Skipped - Autopilot is PAUSED');
    return;
  }

  const userId = getUserId();
  if (!userId) return;

  const settings = state.getSettings(userId);
  if (!settings.autoBulkRepair) {
    if (DEBUG_MODE) {
      logger.log('[Auto-Repair] Feature disabled in settings');
    }
    return;
  }

  try {
    const threshold = settings.maintenanceThreshold;

    const bunker = await gameapi.fetchBunkerState();
    const vessels = await gameapi.fetchVessels();

    const vesselsNeedingRepair = vessels.filter(v => v.wear >= threshold);

    if (DEBUG_MODE) {
      logger.log(`[Auto-Repair] Found ${vesselsNeedingRepair.length} vessels with wear >= ${threshold}%`);
    }

    if (vesselsNeedingRepair.length === 0) {
      if (DEBUG_MODE) {
        logger.log('[Auto-Repair] No vessels need repair');
      }
      return;
    }

    // Check minimum cash balance
    const minCash = settings.autoBulkRepairMinCash !== undefined ? settings.autoBulkRepairMinCash : 0;
    if (bunker.cash &lt; minCash) {
      logger.log(`[Auto-Repair] Cash balance $${bunker.cash.toLocaleString()} below minimum $${minCash.toLocaleString()}`);
      return;
    }

    const vesselIds = vesselsNeedingRepair.map(v => v.id);
    const costData = await gameapi.getMaintenanceCost(vesselIds);

    if (DEBUG_MODE) {
      logger.log(`[Auto-Repair] Repair cost: $${costData.totalCost.toLocaleString()} | Cash: $${bunker.cash.toLocaleString()}`);
    }

    if (costData.totalCost === 0) {
      logger.log('[Auto-Repair] API returned $0 cost - attempting repair anyway (API bug workaround)');
    }

    // Always attempt repair if we have enough cash (or if cost is $0, which may be an API bug)
    if (costData.totalCost === 0 || bunker.cash >= costData.totalCost) {
      const result = await gameapi.bulkRepairVessels(vesselIds);

      logger.log(`[Auto-Repair] Repaired ${result.count} vessels - API returned cost: $${result.totalCost.toLocaleString()}, Calculated cost: $${costData.totalCost.toLocaleString()}`);

      if (broadcastToUser) {
        if (DEBUG_MODE) {
          logger.log(`[Auto-Repair] Broadcasting vessels_repaired event (Desktop notifications: ${settings.enableDesktopNotifications ? 'ENABLED' : 'DISABLED'})`);
        }

        // Build vessel list with names, wear, and costs
        const vesselList = vesselsNeedingRepair.map(vessel => {
          // Find cost data for this vessel
          const costVessel = costData.vessels.find(v => v.id === vessel.id);
          const wearMaintenance = costVessel?.maintenance_data?.find(m => m.type === 'wear');
          const cost = wearMaintenance?.price || 0;

          return {
            id: vessel.id,
            name: vessel.name,
            wear: vessel.wear,
            cost: cost
          };
        });

        broadcastToUser(userId, 'vessels_repaired', {
          count: result.count,
          totalCost: costData.totalCost,
          vessels: vesselList
        });
      }

      // Update all data to refresh repair badge count (SKIP if locked)
      await tryUpdateAllData();
    } else {
      logger.log(`[Auto-Repair] Insufficient funds: need $${costData.totalCost.toLocaleString()}, have $${bunker.cash.toLocaleString()}`);
    }

  } catch (error) {
    logger.error('[Auto-Repair] Error:', error.message);
  }
}

// ============================================================================
// Auto Campaign Renewal
// ============================================================================

/**
 * Auto campaign renewal for a single user.
 * Called by central autopilot monitor when campaigns &lt; 3.
 *
 * @param {number} userId - User ID
 * @param {Object} campaignData - Optional pre-fetched campaign data to avoid duplicate API calls
 */
async function autoCampaignRenewal(campaignData = null) {
  // Check if autopilot is paused
  if (autopilotPaused) {
    logger.log('[Auto-Campaign] Skipped - Autopilot is PAUSED');
    return;
  }

  const userId = getUserId();
  if (!userId) return;

  const settings = state.getSettings(userId);
  if (!settings.autoCampaignRenewal) {
    if (DEBUG_MODE) {
      logger.log('[Auto-Campaign] Feature disabled in settings');
    }
    return;
  }

  try {
    const campaigns = campaignData || await gameapi.fetchCampaigns();

    const activeCampaigns = campaigns.active || [];
    const availableCampaigns = campaigns.available || [];

    logger.debug(`[Auto-Campaign] Active campaigns: ${activeCampaigns.length}, Available: ${availableCampaigns.length}`);

    // Check which types are active
    const activeCampaignTypes = new Set(activeCampaigns.map(c => c.option_name));
    logger.debug(`[Auto-Campaign] Active types: ${Array.from(activeCampaignTypes).join(', ') || 'none'}`);

    // Find all types that are NOT active (need renewal)
    const allPossibleTypes = ['reputation', 'awareness', 'green'];
    const typesToRenew = allPossibleTypes.filter(type => !activeCampaignTypes.has(type));

    logger.debug(`[Auto-Campaign] Types needing renewal: ${typesToRenew.join(', ') || 'none'}`);

    if (typesToRenew.length === 0) {
      logger.log('[Auto-Campaign] All campaign types are active, no renewal needed');
      return;
    }

    const bunker = await gameapi.fetchBunkerState();
    const settings = state.getSettings(userId);

    // Check minimum cash balance
    const minCash = settings.autoCampaignRenewalMinCash !== undefined ? settings.autoCampaignRenewalMinCash : 0;
    if (bunker.cash &lt; minCash) {
      logger.debug(`[Auto-Campaign] Cash balance $${bunker.cash.toLocaleString()} below minimum $${minCash.toLocaleString()}`);
      return;
    }
    let currentCash = bunker.cash;

    const renewed = [];

    for (const type of typesToRenew) {
      // Find best affordable campaign of this type (most expensive that we can afford)
      const campaignsOfType = availableCampaigns
        .filter(c => c.option_name === type &amp;&amp; c.price &lt;= currentCash)
        .sort((a, b) => b.price - a.price); // Most expensive first

      if (campaignsOfType.length > 0) {
        const campaign = campaignsOfType[0];

        try {
          await gameapi.activateCampaign(campaign.id);
          renewed.push({ type, name: campaign.name, price: campaign.price, duration: campaign.duration });
          currentCash -= campaign.price;
          logger.debug(`[Auto-Campaign] Renewed "${campaign.name}" (${type}) - Cost: $${campaign.price.toLocaleString()}, Duration: ${campaign.duration}h`);
        } catch (error) {
          logger.error(`[Auto-Campaign] Failed to renew ${type}:`, error.message);
        }
      } else {
        logger.debug(`[Auto-Campaign] No affordable ${type} campaigns (cash: $${currentCash.toLocaleString()})`);
      }
    }

    if (renewed.length > 0) {
      // Log summary
      const summary = renewed.map(r => `${r.name} (${r.duration}h, $${r.price.toLocaleString()})`).join(', ');
      logger.log(`[Auto-Campaign] Renewed ${renewed.length} campaign(s): ${summary}`);

      if (broadcastToUser) {
        const settings = state.getSettings(userId);
        logger.debug(`[Auto-Campaign] Broadcasting campaigns_renewed (Desktop notifications: ${settings.enableDesktopNotifications ? 'ENABLED' : 'DISABLED'})`);
        broadcastToUser(userId, 'campaigns_renewed', {
          campaigns: renewed
        });
      } else {
        logger.error('[Auto-Campaign] broadcastToUser is NULL, cannot send notification!');
      }

      // Update all data to refresh campaign badge and cash/points (SKIP if locked)
      await tryUpdateAllData();
    }

  } catch (error) {
    logger.error('[Auto-Campaign] Error:', error.message);
  }
}

// ============================================================================
// Header Badge Updates (independent from automation features)
// ============================================================================

/**
 * Updates repair count badge for all users.
 * Called by scheduler every 60 seconds.
 */
async function updateRepairCount() {
  const userId = getUserId();
  if (!userId) return;

  try {
    const settings = state.getSettings(userId);
    const threshold = settings.maintenanceThreshold;

    const vessels = await gameapi.fetchVessels();
    const repairCount = vessels.filter(v => v.wear >= threshold).length;

    if (broadcastToUser) {
      broadcastToUser(userId, 'repair_count_update', {
        count: repairCount
      });
    }
  } catch (error) {
    logger.error('[Header] Failed to update repair count:', error.message);
  }
}

/**
 * Updates campaign status for all users.
 * Called by scheduler every 60 seconds.
 */
async function updateCampaigns() {
  const userId = getUserId();
  if (!userId) return;

  try {
    const campaigns = await gameapi.fetchCampaigns();
    const activeCount = campaigns.active?.length || 0;

    if (broadcastToUser) {
      broadcastToUser(userId, 'campaign_status_update', {
        activeCount: activeCount,
        active: campaigns.active || []
      });
    }
  } catch (error) {
    logger.error('[Header] Failed to update campaigns:', error.message);
  }
}

/**
 * Updates unread message count for all users.
 * Called by scheduler every 30 seconds.
 */
async function updateUnreadMessages() {
  // DISABLED: Messenger polling now handled by 10-second WebSocket interval
  // This prevents duplicate API calls and reduces load
  return;

  /*
  const userId = getUserId();
  if (!userId) return;

  try {
    const unreadCount = await gameapi.fetchUnreadMessages();

    if (broadcastToUser) {
      broadcastToUser(userId, 'unread_messages_update', {
        count: unreadCount
      });
    }
  } catch (error) {
    logger.error('[Header] Failed to update unread messages:', error.message);
  }
  */
}

// ============================================================================
// Auto-COOP
// ============================================================================

/**
 * Automatically sends available COOP vessels to alliance members.
 * Runs every 3 hours (0, 3, 6, 9, 12, 15, 18, 21 UTC).
 *
 * Logic:
 * - Check if COOP available
 * - Filter members who can receive (can_receive_coop === true)
 * - Sort by total_vessels DESC (largest fleets first)
 * - Send to each member until all COOP vessels distributed
 *
 * @async
 * @returns {Promise&lt;void>}
 */
async function autoCoop() {
  // Check if autopilot is paused
  if (autopilotPaused) {
    logger.log('[Auto-COOP] Skipped - Autopilot is PAUSED');
    return;
  }

  const userId = getUserId();
  if (!userId) {
    logger.log('[Auto-COOP] No user ID available, skipping');
    return;
  }

  const settings = state.getSettings(userId);
  if (!settings.autoCoopEnabled) {
    logger.log('[Auto-COOP] Auto-COOP is DISABLED in settings, skipping');
    return;
  }

  try {
    logger.log('[Auto-COOP] ========================================');
    logger.log('[Auto-COOP] Starting Auto-COOP distribution');
    logger.log('[Auto-COOP] ========================================');

    // Fetch COOP data with restrictions from our own API
    const axios = require('axios');
    const coopResponse = await axios.get('https://localhost:12345/api/coop/data', {
      httpsAgent: new (require('https').Agent)({ rejectUnauthorized: false })
    });

    const coopData = coopResponse.data;
    const available = coopData.data?.coop?.available || 0;
    const members = coopData.data?.members_coop || [];

    if (available === 0) {
      logger.log('[Auto-COOP] No COOP vessels available to send');
      return;
    }

    logger.log(`[Auto-COOP] Available COOP vessels: ${available}`);

    // Filter members who can receive (no restrictions)
    const eligibleMembers = members.filter(m => m.can_receive_coop === true &amp;&amp; m.total_vessels > 0);

    if (eligibleMembers.length === 0) {
      logger.log('[Auto-COOP] No eligible members found (all have restrictions or no vessels)');

      // Notify user
      if (broadcastToUser) {
        broadcastToUser(userId, 'auto_coop_no_targets', {
          available,
          reason: 'All members have restrictions or no vessels'
        });
      }
      return;
    }

    // Sort by total_vessels DESC (largest fleets first)
    eligibleMembers.sort((a, b) => b.total_vessels - a.total_vessels);

    logger.log(`[Auto-COOP] Found ${eligibleMembers.length} eligible members`);

    // Track totals
    let totalSent = 0;
    let totalRequested = 0;
    const results = [];

    // Send to each eligible member
    for (const member of eligibleMembers) {
      // Refresh COOP data to get current available count
      const refreshResponse = await axios.get('https://localhost:12345/api/coop/data', {
        httpsAgent: new (require('https').Agent)({ rejectUnauthorized: false })
      });
      const currentAvailable = refreshResponse.data.data?.coop?.available || 0;

      if (currentAvailable === 0) {
        logger.log('[Auto-COOP] All COOP vessels distributed, stopping');
        break;
      }

      const maxToSend = Math.min(currentAvailable, member.total_vessels);

      logger.log(`[Auto-COOP] Sending ${maxToSend} vessels to ${member.company_name} (${member.user_id})...`);

      try {
        // Send via our own API endpoint
        const sendResponse = await axios.post('https://localhost:12345/api/coop/send-max', {
          user_id: member.user_id
        }, {
          httpsAgent: new (require('https').Agent)({ rejectUnauthorized: false })
        });

        const result = sendResponse.data;
        totalRequested += result.requested;
        totalSent += result.departed;

        results.push({
          user_id: member.user_id,
          company_name: member.company_name,
          requested: result.requested,
          departed: result.departed,
          partial: result.partial
        });

        logger.log(`[Auto-COOP] OK Sent ${result.departed} of ${result.requested} to ${member.company_name}`);

        // Small delay between sends to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 500));

      } catch (error) {
        logger.error(`[Auto-COOP] Failed to send to ${member.company_name}:`, error.message);
        results.push({
          user_id: member.user_id,
          company_name: member.company_name,
          error: error.message
        });
      }
    }

    logger.log('[Auto-COOP] ========================================');
    logger.log(`[Auto-COOP] Distribution complete: ${totalSent}/${totalRequested} vessels sent to ${results.length} members`);
    logger.log('[Auto-COOP] ========================================');

    // Broadcast results to user
    if (broadcastToUser) {
      logger.log(`[Auto-COOP] Broadcasting auto_coop_complete event (Desktop notifications: ${settings.enableDesktopNotifications ? 'ENABLED' : 'DISABLED'})`);
      broadcastToUser(userId, 'auto_coop_complete', {
        totalRequested,
        totalSent,
        results
      });
    }

    // Invalidate COOP cache since we changed the available count
    if (totalSent > 0) {
      cache.invalidateCoopCache();
      await tryUpdateAllData();
    }

  } catch (error) {
    // AggregateError contains multiple errors in .errors array
    if (error.errors &amp;&amp; Array.isArray(error.errors)) {
      logger.error('[Auto-COOP] Error during auto-COOP (AggregateError with multiple errors):');
      error.errors.forEach((err, index) => {
        logger.error(`[Auto-COOP] Error ${index + 1}/${error.errors.length}:`, err);
      });
    } else {
      logger.error('[Auto-COOP] Error during auto-COOP:', error);
    }
  }
}

/**
 * Updates vessel count for all users.
 * Called by scheduler based on headerVesselInterval setting.
 */
async function updateVesselCount() {
  const userId = getUserId();
  if (!userId) return;

  try {
    const vessels = await gameapi.fetchVessels();

    const readyToDepart = vessels.filter(v => v.status === 'port').length;
    const atAnchor = vessels.filter(v => v.status === 'anchor').length;
    const pending = vessels.filter(v => v.status === 'pending').length;

    if (broadcastToUser) {
      broadcastToUser(userId, 'vessel_count_update', {
        readyToDepart,
        atAnchor,
        pending
      });
    }
  } catch (error) {
    logger.error('[Header] Failed to update vessel count:', error.message);
  }
}

/**
 * Lock to prevent parallel execution of updateAllData
 */
let updateAllDataLock = false;

/**
 * Cache for bunker capacity values to only broadcast when changed
 * Structure: { userId: { maxFuel: number, maxCO2: number } }
 */
const capacityCache = new Map();

/**
 * Gets cached capacity values for a user, or fetches them if not cached.
 * Used by routes to avoid sending 0 capacity when API doesn't return capacity fields.
 *
 * @param {number} userId - User ID
 * @returns {{maxFuel: number, maxCO2: number}} Capacity values in tons
 */
function getCachedCapacity(userId) {
  const cached = capacityCache.get(userId);
  if (cached) {
    return cached;
  }

  // No cache - return 0 (will be updated on next scheduler run)
  return { maxFuel: 0, maxCO2: 0 };
}

/**
 * Wrapper for updateAllData() with lock check.
 * SKIP if already running, no queuing.
 * Used by autopilot functions to avoid duplicate API calls.
 */
async function tryUpdateAllData() {
  if (updateAllDataLock) {
    logger.debug('[UpdateAll] Already running, skipping');
    return;
  }
  await updateAllData();
}

/**
 * Fetches ALL game data and broadcasts to clients.
 * Called every 30s when any autopilot active, or per settings intervals.
 *
 * IMPORTANT: This function should ALWAYS run, even when autopilot is paused!
 * It only fetches and displays data, it doesn't perform any automated actions.
 * The harbor badges, vessel counts, etc. should always stay updated.
 *
 * Single API call to /game/index gets most data, then supplement with specifics.
 */
async function updateAllData() {
  // NOTE: NO CHECK for autopilotPaused here - this should always run!
  const userId = getUserId();
  if (!userId) return;

  // Prevent parallel execution
  if (updateAllDataLock) {
    if (DEBUG_MODE) {
      logger.log('[UpdateAll] Already running, skipping...');
    }
    return;
  }

  updateAllDataLock = true;

  try {
    if (DEBUG_MODE) {
      logger.log('[UpdateAll] Fetching all game data...');
    }

    // OPTIMIZED: Single /game/index call gets most data at once
    const gameIndexData = await apiCall('/game/index', 'POST', {});

    const user = gameIndexData.user;
    const gameSettings = gameIndexData.data.user_settings;
    const vessels = gameIndexData.data.user_vessels || [];
    const eventArray = gameIndexData.data.event || [];

    // Extract event data if available
    const eventData = eventArray.length > 0 ? eventArray[0] : null;

    // Get local settings for maintenance threshold
    const localSettings = state.getSettings(userId);

    // Additional API calls for data not in /game/index
    // Use cached data when available to reduce duplicate API calls
    const [campaigns, coopData, allianceData] = await Promise.all([
      gameapi.fetchCampaigns(),  // Already uses campaign cache
      fetchCoopDataCached(),
      fetchAllianceDataCached()
    ]);

    // Add coop_boost from alliance data
    if (allianceData.data?.alliance?.benefit?.coop_boost &amp;&amp; coopData.data?.coop) {
      coopData.data.coop.coop_boost = allianceData.data.alliance.benefit.coop_boost;
    }

    // Prices are ONLY fetched by updatePrices() scheduler at :01 and :31 each hour
    // This eliminates 60 redundant API calls per hour (prices only change 2x/hour)

    // === Vessel Counts ===
    const readyToDepart = vessels.filter(v => v.status === 'port').length;
    const atAnchor = vessels.filter(v => v.status === 'anchor').length;
    const pending = vessels.filter(v => v.status === 'pending').length;

    const vesselCounts = { readyToDepart, atAnchor, pending };
    state.updateVesselCounts(userId, vesselCounts);

    if (broadcastToUser) {
      broadcastToUser(userId, 'vessel_count_update', vesselCounts);
    }

    // === Repair Count ===
    const repairCount = vessels.filter(v => v.wear >= localSettings.maintenanceThreshold).length;
    state.updateRepairCount(userId, repairCount);

    if (broadcastToUser) {
      broadcastToUser(userId, 'repair_count_update', { count: repairCount });
    }

    // === Campaign Status ===
    const activeCount = campaigns.active?.length || 0;
    const campaignStatus = { activeCount };
    state.updateCampaignStatus(userId, campaignStatus);

    if (broadcastToUser) {
      broadcastToUser(userId, 'campaign_status_update', campaignStatus);
    }

    // === Messages ===
    // NOTE: Messages are now handled by 10-second WebSocket polling interval
    // No longer broadcast here to avoid duplicate updates

    // === Bunker State (fuel, CO2, cash, points) ===
    // Extract from /game/index response
    if (!gameSettings || !gameSettings.max_fuel || !gameSettings.max_co2) {
      logger.error('[UpdateAll] ERROR: user_settings or capacity fields missing from API response!');
      logger.error('[UpdateAll] gameSettings:', gameSettings);
    }

    const newMaxFuel = (gameSettings?.max_fuel || 0) / 1000;
    const newMaxCO2 = (gameSettings?.max_co2 || 0) / 1000;

    // Check if capacity values have changed
    const cachedCapacity = capacityCache.get(userId);
    const capacityChanged = !cachedCapacity ||
      cachedCapacity.maxFuel !== newMaxFuel ||
      cachedCapacity.maxCO2 !== newMaxCO2;

    if (capacityChanged) {
      // Update cache
      capacityCache.set(userId, { maxFuel: newMaxFuel, maxCO2: newMaxCO2 });
      if (DEBUG_MODE) {
        logger.log(`[UpdateAll] Capacity changed - Fuel: ${newMaxFuel}t, CO2: ${newMaxCO2}t`);
      }
    }

    // Always update bunker state with all values (frontend needs maxFuel/maxCO2 for display)
    const bunkerUpdate = {
      fuel: user.fuel / 1000,        // Convert kg to tons
      co2: user.co2 / 1000,          // Convert kg to tons
      cash: user.cash,
      points: user.points,
      maxFuel: newMaxFuel,           // Always send (needed for frontend display)
      maxCO2: newMaxCO2              // Always send (needed for frontend display)
    };
    state.updateBunkerState(userId, bunkerUpdate);

    if (broadcastToUser) {
      // Use helper function that ALWAYS includes current prices to prevent race condition
      const { broadcastBunkerUpdate } = require('./websocket');
      broadcastBunkerUpdate(userId, bunkerUpdate);
    }

    // === Prices ===
    // Price updates now handled ONLY by updatePrices() scheduler at :01 and :31
    // Prices are available from state.getPrices() for UI display

    // === COOP Targets ===
    // Only broadcast coop data if user is in an alliance
    if (coopData.data?.coop &amp;&amp; allianceData.data?.alliance) {
      const coop = coopData.data.coop;
      const coopUpdate = {
        available: coop.available,
        cap: coop.cap,
        coop_boost: coop.coop_boost
      };
      state.updateCoopData(userId, coopUpdate);

      if (broadcastToUser) {
        broadcastToUser(userId, 'coop_update', coopUpdate);
      }
    }

    // === Stock Price &amp; Anchor Capacity ===
    // Extract from /game/index response (already fetched)
    const stockValue = user.stock_value;
    const stockTrend = user.stock_trend;
    const ipo = user.ipo;
    const maxAnchorPoints = gameSettings.anchor_points;
    const totalVessels = vessels.length;
    const availableCapacity = maxAnchorPoints - totalVessels;

    // Calculate pending anchor points based on anchor_next_build timestamp
    const anchorNextBuild = gameSettings.anchor_next_build || null;
    const now = Math.floor(Date.now() / 1000);
    const pendingAnchorPoints = (anchorNextBuild &amp;&amp; anchorNextBuild > now) ? 1 : 0;

    const headerUpdate = {
      stock: { value: stockValue, trend: stockTrend, ipo },
      anchor: {
        available: availableCapacity,
        max: maxAnchorPoints,
        pending: pendingAnchorPoints,
        nextBuild: anchorNextBuild  // Unix timestamp when next anchor point will be ready
      }
    };
    state.updateHeaderData(userId, headerUpdate);

    if (broadcastToUser) {
      broadcastToUser(userId, 'header_data_update', headerUpdate);
    }

    // === Event Data ===
    // Broadcast complete event data if available
    if (DEBUG_MODE) {
      logger.log('[UpdateAll] Event data:', eventData ? `Found event: ${eventData.name}` : 'No active event');
    }
    if (eventData) {
      state.updateEventData(userId, eventData);
      if (broadcastToUser) {
        broadcastToUser(userId, 'event_data_update', eventData);
      }
    }

    // === Hijacking Status ===
    // Refresh hijacking badge data
    await refreshHijackingBadge();

    // Send completion event to frontend
    if (broadcastToUser) {
      broadcastToUser(userId, 'all_data_updated', { timestamp: Date.now() });
    }

    if (DEBUG_MODE) {
      logger.log('[UpdateAll] All data broadcasted successfully');
    }

  } catch (error) {
    logger.error('[UpdateAll] Failed to fetch all data:', error.message);
  } finally {
    updateAllDataLock = false;
  }
}

/**
 * Analyze vessels and determine which ones should depart based on profitability.
 * This is the CORE logic that should be used by BOTH manual and auto departure!
 *
 * @param {Array} allVessels - All user vessels
 * @param {Array} assignedPorts - All assigned ports with demand data
 * @param {Object} settings - User settings including utilization thresholds
 * @returns {Object} { toDepart: Array, toSkip: Array } with reasons
 */
async function analyzeVesselDepartures(allVessels, assignedPorts, settings) {
  const harbourVessels = allVessels.filter(v => v.status === 'port' &amp;&amp; !v.is_parked);
  const toDepart = [];
  const toSkip = [];

  // Group vessels by destination and type
  const vesselsByDestinationAndType = {};

  for (const vessel of harbourVessels) {
    // Skip vessels with no route
    if (!vessel.route_destination) {
      toSkip.push({
        vessel,
        reason: 'No route assigned'
      });
      continue;
    }

    // Skip vessels with delivery contracts
    if (vessel.delivery_price !== null &amp;&amp; vessel.delivery_price > 0) {
      toSkip.push({
        vessel,
        reason: `Delivery contract active ($${vessel.delivery_price})`
      });
      continue;
    }

    const destination = vessel.route_destination;
    const type = vessel.capacity_type;
    const key = `${destination}_${type}`;

    if (!vesselsByDestinationAndType[key]) {
      vesselsByDestinationAndType[key] = [];
    }
    vesselsByDestinationAndType[key].push(vessel);
  }

  // Process each destination+type group
  for (const key in vesselsByDestinationAndType) {
    const vessels = vesselsByDestinationAndType[key];
    const firstVessel = vessels[0];
    const vesselType = firstVessel.capacity_type;

    // Determine destination
    let destination;
    if (firstVessel.route_destination === firstVessel.current_port_code) {
      destination = firstVessel.route_origin;
    } else {
      destination = firstVessel.route_destination;
    }

    // Find port data
    const port = assignedPorts.find(p => p.code === destination);
    if (!port) {
      vessels.forEach(v => toSkip.push({
        vessel: v,
        reason: `Port ${destination} not in assigned ports`
      }));
      continue;
    }

    // Calculate remaining demand
    const remainingDemand = calculateRemainingDemand(port, vesselType);

    // SIMPLIFIED DEMAND CHECK:
    // Demand is reduced as soon as a ship departs (by the game API).
    // We don't need to calculate vessels en-route or track demand per vessel.
    // Each vessel just checks: Is demand > 0? If yes, depart.

    /* OLD COMPLEX LOGIC (commented out):
    // Find vessels en-route
    const vesselsEnroute = allVessels.filter(v =>
      v.status === 'enroute' &amp;&amp;
      v.route_destination === destination &amp;&amp;
      v.capacity_type === vesselType
    );

    // Calculate capacity en-route
    const capacityEnroute = vesselsEnroute.reduce((sum, v) => sum + getTotalCapacity(v), 0);

    // Effective demand
    let effectiveDemand = Math.max(0, remainingDemand - capacityEnroute);
    */

    if (remainingDemand &lt;= 0) {
      vessels.forEach(v => toSkip.push({
        vessel: v,
        reason: `No demand at ${destination}`
      }));
      continue;
    }

    // Sort vessels by capacity (largest first)
    const sortedVessels = vessels.sort((a, b) => getTotalCapacity(b) - getTotalCapacity(a));

    // Decide for each vessel
    for (const vessel of sortedVessels) {
      const vesselCapacity = getTotalCapacity(vessel);

      // Skip if no demand at destination (simple check)
      if (remainingDemand &lt;= 0) {
        toSkip.push({
          vessel,
          reason: `No demand at ${destination}`
        });
        continue;
      }

      // Check utilization based on full remaining demand
      const cargoToLoad = Math.min(remainingDemand, vesselCapacity);
      const utilizationRate = vesselCapacity > 0 ? cargoToLoad / vesselCapacity : 0;
      const minUtilization = settings.minVesselUtilization / 100;

      if (utilizationRate &lt; minUtilization) {
        toSkip.push({
          vessel,
          reason: `Low utilization (${(utilizationRate * 100).toFixed(0)}% &lt; ${settings.minVesselUtilization}% min)`
        });
        continue;
      }

      // This vessel is profitable to send!
      toDepart.push({
        vessel,
        destination,
        cargoToLoad,
        utilizationRate,
        remainingDemand  // Use remainingDemand instead of effectiveDemand
      });

      // NOTE: We don't reduce demand here - each vessel checks current demand independently
      // The game API will reduce demand when the vessel actually departs
    }
  }

  return { toDepart, toSkip };
}

// ============================================================================
// Auto-Purchase Anchor Points
// ============================================================================

/**
 * Auto-purchase anchor points respecting construction timer.
 * Checks construction timer, price threshold, and cash availability before purchase.
 *
 * Decision Logic:
 * 1. Check if anchor point is currently under construction (anchor_next_build timestamp)
 * 2. If construction active: SKIP purchase (prevents timer reset)
 * 3. Fetch current anchor point price from API
 * 4. Calculate total cost (price  autoAnchorPointAmount)
 * 5. Check cash balance >= minCash + totalCost (must stay above minimum)
 * 6. Purchase anchor points via /anchor-point/purchase-anchor-points
 * 7. Wait for construction to complete naturally (no exploit)
 * 8. Update bunker cash and broadcast notification
 *
 * Construction Timer Safety:
 * - CRITICAL: Buying while construction is active resets the timer to 0
 * - This wastes money and time (construction starts over from 0%)
 * - Only buy when anchor_next_build is null or timestamp &lt; now
 * - Respects same timer logic as UI buttons
 *
 * Safety Features:
 * - Ensures cash stays ABOVE minimum (not just equal to)
 * - Pre-calculates remaining cash after purchase
 * - Only buys if remaining >= minCash (prevents going below minimum)
 * - Respects construction timer (prevents costly timer resets)
 *
 * Price Threshold:
 * - Currently NO price threshold check (always buys if cash available)
 * - Could add autoAnchorPointMaxPrice setting in future
 * - Price typically increases with each purchase
 *
 * API Interactions:
 * - /anchor-point/get-anchor-price - Fetch current price
 * - /anchor-point/purchase-anchor-points - Execute purchase
 *
 * Broadcasting:
 * - 'user_action_notification' - Formatted purchase confirmation
 * - 'bunker_update' - Updated cash balance
 * - 'desktop_notification' - Optional browser notification
 *
 * @async
 * @param {number} userId - User ID for state management
 * @returns {Promise&lt;void>}
 */
async function autoAnchorPointPurchase(userId) {
  // Check if autopilot is paused
  if (autopilotPaused) {
    logger.log('[Auto-Anchor Purchase] Skipped - Autopilot is PAUSED');
    return;
  }

  if (!userId) return;

  const settings = state.getSettings(userId);
  if (!settings.autoAnchorPointEnabled) {
    if (DEBUG_MODE) {
      logger.log('[Auto-Anchor Purchase] Feature disabled in settings');
    }
    return;
  }

  try {
    // CRITICAL: Check if anchor point is currently under construction
    // Buying while construction is active resets the timer (wastes money and time!)
    const headerData = state.getHeaderData(userId);
    const anchorNextBuild = headerData?.anchor?.nextBuild;
    const now = Math.floor(Date.now() / 1000);

    if (anchorNextBuild &amp;&amp; anchorNextBuild > now) {
      const remaining = anchorNextBuild - now;
      const minutes = Math.floor(remaining / 60);
      logger.debug(`[Auto-Anchor] Construction in progress - ${minutes} minutes remaining. Skipping purchase to prevent timer reset.`);
      return;
    }

    const bunker = state.getBunkerState(userId);

    // Fetch current price
    const priceData = await apiCall('/anchor-point/get-anchor-price', 'POST', {});
    const price = priceData.data.price;

    // IMPORTANT: Game API only accepts amount: 1 or amount: 10
    // Use configured amount from settings (defaults to 1 if not set)
    const amount = settings.autoAnchorPointAmount !== undefined ? settings.autoAnchorPointAmount : 1;

    logger.debug(`[Auto-Anchor] Checking purchase conditions - Price: $${price.toLocaleString()}/point, Amount: ${amount} point, Current Cash: $${bunker.cash.toLocaleString()}`);

    // Calculate total cost
    const totalCost = price * amount;

    // Check minimum cash requirement FIRST
    const minCash = settings.autoAnchorPointMinCash !== undefined ? settings.autoAnchorPointMinCash : 0;

    // Only buy if we are ABOVE the minimum cash limit
    if (bunker.cash &lt;= minCash) {
      logger.debug(`[Auto-Anchor] Skipping: Cash $${bunker.cash.toLocaleString()} is at or below minimum $${minCash.toLocaleString()}`);
      return;
    }

    // Check if we have enough cash for the purchase
    if (totalCost > bunker.cash) {
      logger.log(`[Auto-Anchor] Insufficient funds: Need $${totalCost.toLocaleString()}, Have $${bunker.cash.toLocaleString()}`);
      return;
    }

    // Calculate remaining cash after purchase
    const remainingCash = bunker.cash - totalCost;

    // Only buy if remaining cash stays above minimum
    if (remainingCash &lt; minCash) {
      logger.log(`[Auto-Anchor] Skipping purchase: Would leave $${remainingCash.toLocaleString()}, need to keep minimum $${minCash.toLocaleString()}`);
      return;
    }

    if (DEBUG_MODE) {
      logger.log(`[Auto-Anchor] Purchasing ${amount} anchor point(s) @ $${price.toLocaleString()}/point = $${totalCost.toLocaleString()}`);
    }

    // Step 1: Purchase anchor points
    const purchaseData = await apiCall('/anchor-point/purchase-anchor-points', 'POST', { amount });

    // Check for errors
    if (purchaseData.error) {
      if (DEBUG_MODE) {
        logger.log(`[Auto-Anchor] Purchase failed: ${purchaseData.error.error || 'Unknown error'}`);
      }
      return;
    }

    // Check if purchase was not successful
    if (!purchaseData.data?.success) {
      if (DEBUG_MODE) {
        logger.log(`[Auto-Anchor] Purchase not successful (API returned success: false)`);
      }
      return;
    }

    // Purchase successful - anchor point will complete construction naturally
    // No exploit used - timer will complete as designed by game

    // Update bunker cash
    bunker.cash -= totalCost;
    state.updateBunkerState(userId, bunker);

    logger.log(`[Auto-Anchor] Success! Purchased ${amount} anchor point(s) for $${totalCost.toLocaleString()}. Construction timer started.`);

    // Broadcast success notification (only once per successful purchase)
    if (broadcastToUser) {
      broadcastToUser(userId, 'user_action_notification', {
        type: 'success',
        message: `
          &lt;div style="font-family: monospace; font-size: 13px;">
            &lt;div style="text-align: center; border-bottom: 2px solid rgba(255,255,255,0.3); padding-bottom: 8px; margin-bottom: 12px;">
              &lt;strong style="font-size: 14px;"> Anchor Point Purchase&lt;/strong>
            &lt;/div>
            &lt;div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
              &lt;span>Amount:&lt;/span>
              &lt;span>&lt;strong>${amount} point${amount > 1 ? 's' : ''}&lt;/strong>&lt;/span>
            &lt;/div>
            &lt;div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
              &lt;span>Price per point:&lt;/span>
              &lt;span>$${price.toLocaleString()}&lt;/span>
            &lt;/div>
            &lt;div style="height: 1px; background: rgba(255,255,255,0.2); margin: 10px 0;">&lt;/div>
            &lt;div style="display: flex; justify-content: space-between; font-size: 15px; margin-bottom: 8px;">
              &lt;span>&lt;strong>Total:&lt;/strong>&lt;/span>
              &lt;span style="color: #ef4444;">&lt;strong>$${totalCost.toLocaleString()}&lt;/strong>&lt;/span>
            &lt;/div>
            &lt;div style="text-align: center; color: #10b981; font-size: 12px; font-style: italic;">
               Instantly available
            &lt;/div>
          &lt;/div>
        `
      });

      // Broadcast updated bunker state (cash decreased)
        broadcastToUser(userId, 'bunker_update', {
          fuel: bunker.fuel,
          co2: bunker.co2,
          cash: bunker.cash,
          maxFuel: bunker.maxFuel,
          maxCO2: bunker.maxCO2
        });

        // Broadcast anchor update with new pending count
        broadcastToUser(userId, 'anchor_update', {
          pending: amount
        });

        // Send browser notification
        if (settings.enableDesktopNotifications &amp;&amp; settings.notifyHarbormaster) {
          broadcastToUser(userId, 'desktop_notification', {
            title: ' Anchorage Chief',
            message: `Purchased ${amount} anchor point${amount > 1 ? 's' : ''} for $${totalCost.toLocaleString()}. Construction started.`,
            type: 'success'
          });
        }
      }

    // Update all data (SKIP if locked)
    await tryUpdateAllData();

  } catch (error) {
    logger.error('[Auto-Anchor] Error:', error.message);
  }
}

/**
 * Calculate how many anchor points are currently pending construction.
 * Returns 0 if no construction in progress or construction finished.
 *
 * @param {number} userId - User ID
 * @returns {number} Number of pending anchor points
 */
function calculatePendingAnchorPoints(userId) {
  const settings = state.getSettings(userId);
  const lastPurchase = settings.lastAnchorPointPurchase;

  if (DEBUG_MODE) {
    logger.log(`[DEBUG] calculatePendingAnchorPoints: lastPurchase=`, lastPurchase);
  }

  // If no purchase recorded, return 0
  if (!lastPurchase || lastPurchase.timestamp === 0) {
    if (DEBUG_MODE) {
      logger.log(`[DEBUG] No purchase recorded, returning 0`);
    }
    return 0;
  }

  const now = Math.floor(Date.now() / 1000);

  // If construction finished, return 0
  if (now >= lastPurchase.timestamp) {
    if (DEBUG_MODE) {
      logger.log(`[DEBUG] Construction finished (now=${now} >= timestamp=${lastPurchase.timestamp}), returning 0`);
    }
    return 0;
  }

  // Construction in progress, return amount
  if (DEBUG_MODE) {
    logger.log(`[DEBUG] Construction in progress, returning amount=${lastPurchase.amount}`);
  }
  return lastPurchase.amount;
}

// =============================================================================
// Cached Data Helpers
// =============================================================================

/**
 * Fetch COOP data with caching
 * @returns {Promise&lt;Object>} COOP API response
 */
async function fetchCoopDataCached() {
  const cached = cache.getCoopCache();
  if (cached) {
    return cached;
  }

  const data = await apiCall('/coop/get-coop-data', 'POST', {});
  cache.setCoopCache(data);
  return data;
}

/**
 * Fetch Alliance data with caching
 * @returns {Promise&lt;Object>} Alliance API response
 */
async function fetchAllianceDataCached() {
  const cached = cache.getAllianceCache();
  if (cached) {
    return cached;
  }

  const data = await apiCall('/alliance/get-user-alliance', 'POST', {});
  cache.setAllianceCache(data);
  return data;
}

// =============================================================================
// Auto-Negotiate Hijacking
// =============================================================================

/**
 * Refreshes hijacking badge and header display for all users.
 * Broadcasts current case counts and hijacked vessel count to all connected clients.
 *
 * @async
 * @function refreshHijackingBadge
 * @returns {Promise&lt;void>}
 */
async function refreshHijackingBadge() {
  try {
    // Use shared cache from websocket.js to reduce duplicate API calls
    const { getCachedMessengerChats, getCachedHijackingCase } = require('./websocket');
    const allChats = await getCachedMessengerChats();

    // Filter for hijacking cases
    const hijackingChats = allChats.filter(chat =>
      chat.system_chat &amp;&amp; chat.body === 'vessel_got_hijacked'
    );

    // Fetch details for each case (using shared cache - no duplicate API calls!)
    const casesWithDetails = await Promise.all(
      hijackingChats.map(async (chat) => {
        const caseId = chat.values?.case_id;
        if (!caseId) return null;

        // Use shared cache function - eliminates duplicate API calls
        return await getCachedHijackingCase(caseId);
      })
    );

    const cases = casesWithDetails.filter(c => c !== null);
    const openCases = cases.filter(c => c.isOpen).length;
    const hijackedCount = cases.filter(c => {
      const status = c.details?.status;
      return status === 'in_progress' || (c.isOpen &amp;&amp; status !== 'solved');
    }).length;

    // Broadcast to current user
    if (broadcastToUser) {
      const userId = getUserId();
      if (userId) {
        broadcastToUser(userId, 'hijacking_update', {
          openCases: openCases,
          totalCases: cases.length,
          hijackedCount: hijackedCount
        });
      }
    }
  } catch (error) {
    logger.error('[Hijacking Badge Refresh] Error:', error.message);
  }
}

/**
 * Automatically negotiates hijacked vessels for the current user.
 * Offers 1% repeatedly until price is below $20,000, then accepts.
 *
 * Algorithm:
 * 1. Get all active hijacking cases
 * 2. For each case, offer 1% of requested amount
 * 3. Wait 3 seconds for API to process
 * 4. Verify the offer was accepted and get new counter-offer
 * 5. If new price >= $20,000: repeat from step 2
 * 6. If new price &lt; $20,000: accept and release vessel
 * 7. Retry on API errors
 *
 * Note: This function uses the global session cookie (single-user system).
 * userId parameter is kept for future multi-user support but not currently used for API calls.
 *
 * @async
 * @function autoNegotiateHijacking
 * @param {number} userId - User ID
 * @param {Object} settings - User settings
 * @returns {Promise&lt;void>}
 */
async function autoNegotiateHijacking() {
  // Check if autopilot is paused
  if (autopilotPaused) {
    logger.log('[Auto-Negotiate Hijacking] Skipped - Autopilot is PAUSED');
    return;
  }

  const userId = getUserId();
  if (!userId) return;

  const settings = state.getSettings(userId);
  if (!settings.autoNegotiateHijacking) {
    if (DEBUG_MODE) {
      logger.log('[Auto-Negotiate Hijacking] Feature disabled in settings');
    }
    return;
  }

  const THRESHOLD = 20000; // Stop negotiating below this amount
  const OFFER_PERCENTAGE = 0.01; // Always offer 1%
  const VERIFY_DELAY = 60000; // Wait 1 minute after offer before verification (pirates need time to respond)
  const MAX_RETRIES = 3; // Retry failed API calls up to 3 times

  try {
    // Use shared cache from websocket.js to reduce duplicate API calls
    const { getCachedMessengerChats } = require('./websocket');
    const chats = await getCachedMessengerChats();

    if (!chats || chats.length === 0) {
      logger.debug('[Auto-Negotiate Hijacking] No messages data');
      return;
    }

    // Find hijacking system messages - check body field directly on chat object
    const hijackingChats = chats.filter(chat => {
      return chat.body === 'vessel_got_hijacked';
    });

    if (hijackingChats.length === 0) {
      logger.debug('[Auto-Negotiate Hijacking] No active hijacking cases');
      return;
    }

    logger.debug(`[Auto-Negotiate Hijacking] Found ${hijackingChats.length} active case(s)`);

    // Process each case sequentially
    let processed = 0;
    for (const chat of hijackingChats) {
      const caseId = chat.values?.case_id;
      const vesselName = chat.values?.vessel_name || 'Unknown Vessel';

      if (!caseId) {
        logger.debug('[Auto-Negotiate Hijacking] Case missing ID, skipping');
        continue;
      }

      try {
        await processHijackingCase(userId, caseId, vesselName, THRESHOLD, OFFER_PERCENTAGE, VERIFY_DELAY, MAX_RETRIES);
        processed++;
      } catch (error) {
        logger.error(`[Auto-Negotiate Hijacking] Error processing case ${caseId}:`, error.message);

        // Send failure notification
        if (broadcastToUser) {
          broadcastToUser(userId, 'hijacking_update', {
            action: 'negotiation_failed',
            data: { case_id: caseId }
          });
        }
      }
    }

    // Update all data if cases were processed (SKIP if locked)
    if (processed > 0) {
      await tryUpdateAllData();
    }

  } catch (error) {
    logger.error('[Auto-Negotiate Hijacking] Error:', error.message);
  }
}

/**
 * Process a single hijacking case: negotiate until below threshold, then accept.
 *
 * @async
 * @function processHijackingCase
 * @param {number} userId - User ID for broadcasts
 * @param {number} caseId - Hijacking case ID
 * @param {string} vesselName - Name of hijacked vessel
 * @param {number} threshold - Price threshold to stop negotiating
 * @param {number} offerPercentage - Percentage to offer (0.01 = 1%)
 * @param {number} verifyDelay - Milliseconds to wait before verification
 * @param {number} maxRetries - Maximum retry attempts
 * @returns {Promise&lt;void>}
 */
async function processHijackingCase(userId, caseId, vesselName, threshold, offerPercentage, verifyDelay, maxRetries) {
  logger.debug(`[Auto-Negotiate Hijacking] Processing case ${caseId}...`);

  let negotiationRound = 0;
  const MAX_ROUNDS = 50; // Safety limit to prevent infinite loops

  while (negotiationRound &lt; MAX_ROUNDS) {
    negotiationRound++;

    // Get current case status
    const caseData = await getCaseWithRetry(caseId, maxRetries);
    if (!caseData) {
      logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Failed to get case data, aborting`);
      return;
    }

    const requestedAmount = caseData.requested_amount;
    const status = caseData.status;

    logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId} Round ${negotiationRound}: Status="${status}", Price=$${requestedAmount}`);

    // Save initial pirate demand to history (only in first round if history is empty)
    if (negotiationRound === 1) {
      try {
        const { getAppDataDir } = require('./config');
        const historyDir = path.join(
          getAppDataDir(),
          'ShippingManagerCoPilot',
          'data',
          'hijack_history'
        );
        const historyPath = path.join(historyDir, `${userId}-${caseId}.json`);

        // Ensure directory exists
        if (!fs.existsSync(historyDir)) {
          fs.mkdirSync(historyDir, { recursive: true });
        }

        // Check if history already exists
        if (!fs.existsSync(historyPath)) {
          // Create new history with initial pirate demand
          const initialHistory = {
            history: [{
              type: 'pirate',
              amount: requestedAmount,
              timestamp: Date.now() / 1000
            }],
            autopilot_resolved: false,
            resolved_at: null
          };

          fs.writeFileSync(historyPath, JSON.stringify(initialHistory, null, 2));
          logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Initial pirate demand $${requestedAmount} saved to history`);
        }
      } catch (error) {
        logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Failed to save initial demand to history:`, error);
      }
    }

    // Broadcast current price to frontend
    if (broadcastToUser) {
      broadcastToUser(userId, 'hijacking_update', {
        action: 'price_check',
        data: {
          case_id: caseId,
          round: negotiationRound,
          current_price: requestedAmount,
          status: status
        }
      });
    }

    // Check if case is already resolved (paid)
    // 'pending_payment' means ready to pay (price under threshold), NOT already paid!
    if (status === 'solved' || status === 'paid') {
      logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Already resolved (status="${status}"), stopping`);
      return;
    }

    // CRITICAL: Check for $0 bug - game charges original amount if we accept at $0!
    if (requestedAmount === 0) {
      logger.warn(`[Auto-Negotiate Hijacking] Case ${caseId}:  CRITICAL BUG - Price is $0! Game will charge original amount if accepted!`);
      logger.warn(`[Auto-Negotiate Hijacking] Case ${caseId}: Attempting to fix by submitting new offers (max 3 attempts)...`);

      let fixAttempts = 0;
      const MAX_FIX_ATTEMPTS = 3;

      while (fixAttempts &lt; MAX_FIX_ATTEMPTS) {
        fixAttempts++;

        // Submit a 1% offer to try to get pirates to respond with non-zero counter
        const fixOfferAmount = 100; // Minimum $100 offer
        logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Fix attempt ${fixAttempts}/${MAX_FIX_ATTEMPTS}: Offering $${fixOfferAmount}`);

        const offered = await submitOfferWithRetry(userId, caseId, fixOfferAmount, maxRetries);
        if (!offered) {
          logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Failed to submit fix offer`);
          continue;
        }

        // Wait for API
        await new Promise(resolve => setTimeout(resolve, verifyDelay));

        // Check if price is now non-zero
        const fixedCase = await getCaseWithRetry(caseId, maxRetries);
        if (fixedCase &amp;&amp; fixedCase.requested_amount > 0) {
          logger.log(`[Auto-Negotiate Hijacking] Case ${caseId}:  Bug fixed! New price: $${fixedCase.requested_amount}`);
          break; // Continue with normal negotiation
        }

        logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Price still $0 after attempt ${fixAttempts}`);
      }

      // Re-check price after fix attempts
      const recheckCase = await getCaseWithRetry(caseId, maxRetries);
      if (!recheckCase || recheckCase.requested_amount === 0) {
        logger.warn(`[Auto-Negotiate Hijacking] Case ${caseId}:  Unable to fix $0 bug, ABORTING to prevent charging original amount`);

        // Send failure notification
        if (broadcastToUser) {
          broadcastToUser(userId, 'hijacking_update', {
            action: 'negotiation_failed',
            data: { case_id: caseId }
          });
        }
        return;
      }

      // Price is now valid, continue to next round
      logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Continuing with valid price $${recheckCase.requested_amount}`);
      continue;
    }

    // Check if we should accept
    if (requestedAmount &lt; threshold) {
      logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Price $${requestedAmount} below threshold $${threshold}, checking cash...`);

      // Check if we have enough cash to pay
      const vesselData = await apiCall('/game/index', 'POST', {});
      const currentCash = vesselData.user.cash;

      if (currentCash &lt; requestedAmount) {
        logger.warn(`[Auto-Negotiate Hijacking] Case ${caseId}: INSUFFICIENT FUNDS - Need $${requestedAmount}, have $${currentCash}`);
        logger.log(`[Auto-Negotiate Hijacking] Case ${caseId}: Skipping case (vessel: ${vesselName})`);

        // Broadcast insufficient funds warning
        if (broadcastToUser) {
          broadcastToUser(userId, 'hijacking_update', {
            action: 'insufficient_funds',
            data: {
              case_id: caseId,
              vessel_name: vesselName,
              required: requestedAmount,
              available: currentCash
            }
          });
        }
        return; // Skip this case
      }

      logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Cash OK ($${currentCash} >= $${requestedAmount}), ACCEPTING`);

      // Broadcast that we're about to accept
      if (broadcastToUser) {
        broadcastToUser(userId, 'hijacking_update', {
          action: 'accepting_price',
          data: {
            case_id: caseId,
            final_price: requestedAmount,
            threshold: threshold
          }
        });
      }

      const accepted = await acceptRansomWithRetry(caseId, maxRetries);
      if (accepted) {
        logger.log(`[Auto-Negotiate Hijacking] Case ${caseId}: ACCEPTED - Vessel released!`);

        // Mark case as autopilot-resolved in history
        try {
          const { getAppDataDir } = require('./config');
          const historyDir = path.join(
            getAppDataDir(),
            'ShippingManagerCoPilot',
            'data',
            'hijack_history'
          );
          const historyPath = path.join(historyDir, `${userId}-${caseId}.json`);

          // Ensure directory exists
          if (!fs.existsSync(historyDir)) {
            fs.mkdirSync(historyDir, { recursive: true });
          }

          // Load existing history if file exists, otherwise start with empty array
          let historyData = [];
          if (fs.existsSync(historyPath)) {
            const existingData = JSON.parse(fs.readFileSync(historyPath, 'utf8'));
            // Handle both old format (array) and new format (object with history property)
            historyData = Array.isArray(existingData) ? existingData : (existingData.history || []);
          }

          // Create updated history with autopilot_resolved flag
          const updatedHistory = {
            history: historyData,
            autopilot_resolved: true,
            resolved_at: Date.now() / 1000
          };

          fs.writeFileSync(historyPath, JSON.stringify(updatedHistory, null, 2));
          logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Marked as autopilot-resolved`);
        } catch (error) {
          logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Failed to mark as autopilot-resolved:`, error);
        }

        // Broadcast success to frontend with Captain Blackbeard message
        if (broadcastToUser) {
          broadcastToUser(userId, 'hijacking_update', {
            action: 'hijacking_resolved',
            data: {
              case_id: caseId,
              final_amount: requestedAmount,
              vessel_name: vesselName,
              success: true
            }
          });
        }
      } else {
        logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Failed to accept ransom`);
      }
      return;
    }

    // Offer 1% of current price
    const offerAmount = Math.floor(requestedAmount * offerPercentage);
    logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Offering $${offerAmount} (${offerPercentage * 100}% of $${requestedAmount})`);

    // Broadcast offer to frontend
    if (broadcastToUser) {
      broadcastToUser(userId, 'hijacking_update', {
        action: 'offer_submitted',
        data: {
          case_id: caseId,
          round: negotiationRound,
          your_offer: offerAmount,
          pirate_demand: requestedAmount
        }
      });
    }

    const offered = await submitOfferWithRetry(userId, caseId, offerAmount, maxRetries);
    if (!offered) {
      logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Failed to submit offer, aborting`);
      return;
    }

    // Wait for API to process
    logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Waiting ${verifyDelay}ms for API to process...`);
    await new Promise(resolve => setTimeout(resolve, verifyDelay));

    // Verify offer was accepted by checking if requested_amount changed
    const verifiedCase = await getCaseWithRetry(caseId, maxRetries);
    if (!verifiedCase) {
      logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Failed to verify offer, aborting`);
      return;
    }

    if (verifiedCase.requested_amount === requestedAmount) {
      logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}:  Price unchanged, API may not have processed offer yet`);
      // Continue to next round anyway - will retry offer if needed
    } else {
      logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}:  Offer processed, new price: $${verifiedCase.requested_amount}`);

      // Save pirate counter-offer to history
      try {
        const { getAppDataDir } = require('./config');
        const historyDir = path.join(
          getAppDataDir(),
          'ShippingManagerCoPilot',
          'data',
          'hijack_history'
        );
        const historyPath = path.join(historyDir, `${userId}-${caseId}.json`);

        // Load existing history
        let historyData = [];
        let autopilotResolved = false;
        let resolvedAt = null;
        if (fs.existsSync(historyPath)) {
          const existingData = JSON.parse(fs.readFileSync(historyPath, 'utf8'));
          historyData = Array.isArray(existingData) ? existingData : (existingData.history || []);
          autopilotResolved = existingData.autopilot_resolved || false;
          resolvedAt = existingData.resolved_at || null;
        }

        // Add pirate counter-offer to history
        historyData.push({
          type: 'pirate',
          amount: verifiedCase.requested_amount,
          timestamp: Date.now() / 1000
        });

        // Save updated history
        const updatedHistory = {
          history: historyData,
          autopilot_resolved: autopilotResolved,
          resolved_at: resolvedAt
        };

        fs.writeFileSync(historyPath, JSON.stringify(updatedHistory, null, 2));
        logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Pirate counter $${verifiedCase.requested_amount} saved to history`);
      } catch (error) {
        logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Failed to save pirate counter to history:`, error);
      }

      // Broadcast pirate counter-offer to frontend
      if (broadcastToUser) {
        broadcastToUser(userId, 'hijacking_update', {
          action: 'pirate_counter_offer',
          data: {
            case_id: caseId,
            round: negotiationRound,
            your_offer: offerAmount,
            pirate_counter: verifiedCase.requested_amount,
            old_price: requestedAmount
          }
        });
      }
    }
  }

  logger.warn(`[Auto-Negotiate Hijacking] Case ${caseId}:  Reached maximum rounds (${MAX_ROUNDS}), stopping`);

  // Send failure notification
  if (broadcastToUser) {
    broadcastToUser(null, {
      type: 'hijacking_update',
      action: 'negotiation_failed',
      data: { case_id: caseId }
    });
  }
}

/**
 * Get hijacking case data with retry logic.
 *
 * @async
 * @function getCaseWithRetry
 * @param {number} userId - User ID
 * @param {number} caseId - Case ID
 * @param {number} maxRetries - Maximum retry attempts
 * @returns {Promise&lt;Object|null>} Case data or null on failure
 */
async function getCaseWithRetry(caseId, maxRetries) {
  // Use shared cache from websocket.js instead of direct API calls
  const { getCachedHijackingCase } = require('./websocket');

  for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {
    try {
      const result = await getCachedHijackingCase(caseId);
      if (result &amp;&amp; result.details) {
        return result.details;
      }
      logger.debug(`[Auto-Negotiate Hijacking] Get case attempt ${attempt}/${maxRetries}: No data`);
    } catch (error) {
      logger.debug(`[Auto-Negotiate Hijacking] Get case attempt ${attempt}/${maxRetries}: ${error.message}`);
    }
    if (attempt &lt; maxRetries) {
      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s between retries
    }
  }
  return null;
}

/**
 * Submit negotiation offer with retry logic.
 *
 * @async
 * @function submitOfferWithRetry
 * @param {number} userId - User ID
 * @param {number} caseId - Case ID
 * @param {number} amount - Offer amount
 * @param {number} maxRetries - Maximum retry attempts
 * @returns {Promise&lt;boolean>} True if successful
 */
async function submitOfferWithRetry(userId, caseId, amount, maxRetries) {
  for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {
    try {
      const response = await apiCall('/hijacking/submit-offer', 'POST', {
        case_id: caseId,
        amount: amount
      });
      if (response) {
        // Save bot's offer to history immediately
        try {
          const { getAppDataDir } = require('./config');
          const historyDir = path.join(
            getAppDataDir(),
            'ShippingManagerCoPilot',
            'data',
            'hijack_history'
          );
          const historyPath = path.join(historyDir, `${userId}-${caseId}.json`);

          // Ensure directory exists
          if (!fs.existsSync(historyDir)) {
            fs.mkdirSync(historyDir, { recursive: true });
          }

          // Load existing history
          let historyData = [];
          let autopilotResolved = false;
          let resolvedAt = null;
          if (fs.existsSync(historyPath)) {
            const existingData = JSON.parse(fs.readFileSync(historyPath, 'utf8'));
            historyData = Array.isArray(existingData) ? existingData : (existingData.history || []);
            autopilotResolved = existingData.autopilot_resolved || false;
            resolvedAt = existingData.resolved_at || null;
          }

          // Add bot's offer to history
          historyData.push({
            type: 'user',
            amount: amount,
            timestamp: Date.now() / 1000
          });

          // Save updated history
          const updatedHistory = {
            history: historyData,
            autopilot_resolved: autopilotResolved,
            resolved_at: resolvedAt
          };

          fs.writeFileSync(historyPath, JSON.stringify(updatedHistory, null, 2));
          logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Bot offer $${amount} saved to history`);
        } catch (error) {
          logger.debug(`[Auto-Negotiate Hijacking] Case ${caseId}: Failed to save bot offer to history:`, error);
        }

        return true;
      }
      logger.debug(`[Auto-Negotiate Hijacking] Submit offer attempt ${attempt}/${maxRetries}: No response`);
    } catch (error) {
      logger.debug(`[Auto-Negotiate Hijacking] Submit offer attempt ${attempt}/${maxRetries}: ${error.message}`);
    }
    if (attempt &lt; maxRetries) {
      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s between retries
    }
  }
  return false;
}

/**
 * Accept ransom with retry logic.
 *
 * @async
 * @function acceptRansomWithRetry
 * @param {number} userId - User ID
 * @param {number} caseId - Case ID
 * @param {number} maxRetries - Maximum retry attempts
 * @returns {Promise&lt;boolean>} True if successful
 */
async function acceptRansomWithRetry(caseId, maxRetries) {
  for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {
    try {
      const response = await apiCall('/hijacking/pay', 'POST', { case_id: caseId });
      if (response) {
        return true;
      }
      logger.debug(`[Auto-Negotiate Hijacking] Accept ransom attempt ${attempt}/${maxRetries}: No response`);
    } catch (error) {
      logger.debug(`[Auto-Negotiate Hijacking] Accept ransom attempt ${attempt}/${maxRetries}: ${error.message}`);
    }
    if (attempt &lt; maxRetries) {
      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s between retries
    }
  }
  return false;
}

// ============================================================================
// Main Event Loop (Event-Driven Autopilot System)
// ============================================================================

const LOOP_INTERVAL = 60000;  // 60 seconds
let previousPrices = null;

/**
 * Main event-driven autopilot loop.
 * Runs every 60 seconds, checks game state, triggers autopilot functions based on conditions.
 */
async function mainEventLoop() {
  const userId = getUserId();
  if (!userId) {
    setTimeout(mainEventLoop, LOOP_INTERVAL);
    return;
  }

  const settings = state.getSettings(userId);
  if (!settings) {
    setTimeout(mainEventLoop, LOOP_INTERVAL);
    return;
  }

  try {
    // Update prices EVERY loop (60 seconds) to keep UI in sync
    await updatePrices();

    // CRITICAL: Validate that we have valid data before running ANY autopilot tasks
    const prices = state.getPrices(userId);
    const bunker = state.getBunkerState(userId);

    // Skip loop if essential data is missing or invalid
    if (!prices || prices.fuel &lt;= 0 || prices.co2 &lt;= 0) {
      logger.warn('[Loop] Skipping - prices not loaded yet (fuel: $' + (prices?.fuel || 0) + ', co2: $' + (prices?.co2 || 0) + ')');
      setTimeout(mainEventLoop, LOOP_INTERVAL);
      return;
    }

    if (!bunker || bunker.cash === undefined || bunker.points === undefined) {
      logger.warn('[Loop] Skipping - bunker data not loaded yet');
      setTimeout(mainEventLoop, LOOP_INTERVAL);
      return;
    }

    // Fetch vessel data to check conditions and update badges
    // ALWAYS fetch (even when autopilot paused) to keep badges current
    const gameData = await apiCall('/game/index', 'POST', {});
    const vessels = gameData.data.user_vessels || [];

    // Count vessels for badges - ALWAYS broadcast (even when paused)
    const readyToDepart = vessels.filter(v => v.status === 'port' &amp;&amp; !v.is_parked).length;
    const atAnchor = vessels.filter(v => v.status === 'anchor').length;
    const pending = vessels.filter(v => v.status === 'pending').length;

    if (broadcastToUser) {
      broadcastToUser(userId, 'vessel_count_update', {
        readyToDepart,
        atAnchor,
        pending
      });
    }

    // === SKIP AUTOMATION IF PAUSED ===
    if (autopilotPaused) {
      if (DEBUG_MODE) {
        logger.log('[Loop] Autopilot paused, skipping automation (badge update completed)');
      }
      setTimeout(mainEventLoop, LOOP_INTERVAL);
      return;
    }

    // Auto-rebuy runs EVERY loop (checks fuel/CO2 levels from state)
    await autoRebuyAll();

    // Vessels ready to depart
    if (settings.autoDepartAll &amp;&amp; readyToDepart > 0) {
      logger.log(`[Loop] ${readyToDepart} vessel(s) ready to depart`);
      await autoDepartVessels();
    }

    // Vessels need repair
    const needsRepair = vessels.filter(v => v.wear >= settings.maintenanceThreshold).length;
    if (settings.autoBulkRepair &amp;&amp; needsRepair > 0) {
      logger.log(`[Loop] ${needsRepair} vessel(s) need repair`);
      await autoRepairVessels();
    }

    // Campaigns need renewal (check from fresh data)
    const campaigns = await gameapi.fetchCampaigns();
    const activeCampaignCount = countActiveCampaignTypes(campaigns);
    if (settings.autoCampaignRenewal &amp;&amp; activeCampaignCount &lt; 3) {
      logger.log(`[Loop] ${activeCampaignCount}/3 campaigns active, checking renewal`);
      await autoCampaignRenewal(campaigns);
    }

    // COOP targets available
    if (settings.autoCoopEnabled) {
      const coopData = await fetchCoopDataCached();  // Use cache
      const available = coopData.data?.coop?.available || 0;
      if (available > 0) {
        logger.log(`[Loop] ${available} COOP target(s) available`);
        await autoCoop();
      }
    }

    // Hijacking cases (UNRESOLVED only)
    if (settings.autoNegotiateHijacking) {
      await autoNegotiateHijacking();
    }

    // NOTE: We do NOT call tryUpdateAllData() here because:
    // - Each autopilot function calls tryUpdateAllData() after completing work
    // - This eliminates duplicate /game/index API calls
    // - The lock prevents parallel execution, but sequential calls still happen
    // - By removing this call, we save ~1 API call per minute

  } catch (error) {
    logger.error('[Loop] FATAL ERROR in main event loop:', error);
    logger.error('[Loop] Stack trace:', error.stack);

    // CRITICAL: Main loop crashed - this should NEVER happen
    // Exit the application to prevent running with broken autopilot
    logger.error('[Loop] Application will exit due to fatal error in main loop');
    process.exit(1);
  }

  // Schedule next loop - ALWAYS 60s
  setTimeout(mainEventLoop, LOOP_INTERVAL);
}

/**
 * Starts the main event loop.
 * Called after initial data load.
 */
function startMainEventLoop() {
  logger.log('[Loop] Starting main event loop (60s interval)');
  mainEventLoop();
}

/**
 * Counts active campaign types (reputation, awareness, green).
 * Used by main loop to check if campaigns need renewal.
 */
function countActiveCampaignTypes(campaigns) {
  const active = campaigns.active || [];
  const activeTypes = new Set(active.map(c => c.option_name));
  const requiredTypes = ['reputation', 'awareness', 'green'];
  return requiredTypes.filter(type => activeTypes.has(type)).length;
}

module.exports = {
  setBroadcastFunction,
  initializeAutopilotState,
  pauseAutopilot,
  resumeAutopilot,
  isAutopilotPaused,
  updatePrices,
  checkPriceAlerts,
  autoRebuyFuel,
  autoRebuyCO2,
  autoRebuyAll,
  departVessels,  // Universal depart function (accepts vessel IDs array)
  autoDepartVessels,  // Autopilot function (departs all vessels)
  autoRepairVessels,
  autoCoop,
  autoAnchorPointPurchase,
  autoNegotiateHijacking,
  autoCampaignRenewal,
  refreshHijackingBadge,
  updateRepairCount,
  updateCampaigns,
  updateUnreadMessages,
  updateAllData,
  tryUpdateAllData,  // Wrapper with lock check
  updateVesselCount,
  getCachedCapacity,
  analyzeVesselDepartures,
  calculateRemainingDemand,
  getTotalCapacity,
  calculatePendingAnchorPoints,
  startMainEventLoop  // Event-driven loop
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation Version: 0.0.7 - ShippingManager CoPilot
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
